###-  Program2 to estimate distribution of non-pathological values from a patient data    -###
###-  Written on 10.03.2010 by Farhad Arzideh (Ar)                                        -###
###-  other authors: Bernd Wolters (Wo)                                                   -###
###-                                                                                      -###
###   01.06.2014 (Wo): cat included                                                        ###
###   01.08.2014 (Wo): null hypthesis and CI testing optional, graphics format optional    ###
###   01.10.2014 (Ar): i)   the calculation of DL (decision limits) is omitted.            ### 
###                    ii)  graphical modifications have been performed.                   ### 
###                    iii) the unnecessary part of the program for displaying             ###  
###                         kde of the whole data is omitted.                              ###
###   12.01.2015 (Ar): error messages are included                                         ###
###   12.01.2015 (Ar): columns for sex and station are redefined; e.g. all rows with       ###
###                    entries "M" or "M " or "M  " transfered to "M" and                  ###
###                    thereby imported.                                                   ###
###   02.02.2015 (Ar): i)   source function are modified.                                  ### 
###                    ii)  graphical display of pathological values are modified:         ### 
###                         path.values are displayed for low- and high values             ###
###                         using gr_all0 and gr_est0 functions.                           ###
###                    iii) this modification was developed to use the tool as default     ###
###                         in windows-system or alternatively in linux-system (e.g. OSM)  ### 
###   20.02.2015 (Ar): estimation of bandwidth (bw) of kernel density function was modified.## 
###   20.04.2015 (Ar): error handling was modified (line 390, 1914).                       ###
###   23.08.2015 (Ar): the choice of option pathological values is automated               ###
###                    if this is not given by user (recommended).                         ###
###   25.08.2015 (Ar): denotation of columns for sex and hospital was changed (row 223)    ### 
###   26.08.2015 (Ar): a subfolder with a special name, generated by the name of the       ###
###                    test value (measurand) + age range + date of analysis, is created   ###
###                    in the   \results folder (if it does not exist). The evaluations    ###
###                    results and graphs) are saved in a subfolder \step2 created         ###
###                    in this subfolder.                                                  ###
###   26.08.2015 (Ar): the estimation of bandwidth for kernel density estimation is        ###
###                    modified for the cases that the sample size is too large.           ### 
###   20.11.2015 (Wo): report of results including age description                         ###
###                    generation of output at the end of code                             ###
###   12.07.2016 (Ar): evaluate p-value of Test: lambda is searched in [0, 1] (see         ###
###                    e.g. row 1000-1001, m1=101)                                         ### 
###   25.07.2016 (Ar): i) A report data, prog_log.txt, will be created and saved in        ###
###                      "result"-file.                                                    ###
###                    ii) running time of program will be calculated and given.           ###
###                    iii) program estimates and yields RLs for male, female or all       ###
###                         subjects, though it is stopped for each of them.               ###
###                    iv) Integrating of same procedure as in iii) for  p-values and      ###
###                        confidence intervals for estimated RLs.                         ###
###                    v)  error handling is modified to give more details.                ###
###  16.08.2016 (Ar):  q10<-round(q10-qstep,2) instead of q10<-q10-qstep                   ### 
###  19.09.2016 (Ar):  special symobols ($, &, /, etc. and empty spaces) in the dataname   ###
###                    are replaced with underline (_).                                    ### 
###  19.09.2016 (Ar):  choice of X-axis range was modified: if (x2==0 | x2 <= x1)          ###
###  23.09.2016 (Ar):  permissable uncertainty is calculated for RLs with function pU      ###
###                  (see Haeckel et al.[2016] "relevant differences of reference limits") ###
###  12.10.2016 (Ar): estimated RLs are rounded at com+1 decimal points                    ### 
###  13.10.2016 (Wo): testunit wird mit testname auf Grafiken ausgegeben                   ### 
###  18.10.2016 (Ar): new variables are defined to analyse the data in a date range        ###    
###  09.11.2016 (Wo): Export of pU behind the LRL an RRL, if no pU then "n.d." in output   ###
###  12.02.2017 (Wo): saving of plots changed (incl. plot_wrapper.r)                       ###
###  01.03.2017 (Wo): logfile now for every step                                           ###
###  23.07.2017 (Wo): logfile renamend to RLE_Prog2.log                                    ###
###  07.09.2017 (Ar): 2 functions to evaluate of p-value have been modified.               ###
###                   See headlines of KS_rtpn_test- and KS_rtpn_th functions.             ###
###  07.09.2017 (Ar): program can be run with time limitations (date1=start date,          ###
###                    or/and date2=end date)                                              ###
###  08.09.2017 (Wo): logfile in Subdirectory of temp data                                 ### 
###  02.05.2018 (Wo): headline of RL_table for 95%CI modified                              ###
###                   some more cat included (estimation, testing, CI)                     ###
###  07.05.2018 (Wo): file_data renamed file_temp for temp subdirectory                    ###
###                   file_data now used for classic only                                  ###
##############################################################################################
rm(list=ls(all=TRUE))
#*************************#
###-  DATA locations   -###
#*************************#
############################################
############################################
###                                      ###
###   1. gives path of the par data      ###
###                                      ###
############################################
############################################
#
cat("read arguments (1.) ....\n")

#
# Arguments are read
#
args1 <- commandArgs()
ar <- which(args1 == "--args")

#
# To get always the last --args one,
#
ar1 <- ar[length(ar)]
args <- args1[(ar1+1):length(args1)]

#
# List args contains now the real arguments
#

#
# DATA locations   
#
INPUT_PAR_FILE <- args[1]
start.time <- date()
##############################################################
##############################################################
###                                                        ###
###   2. assignment of variables in R from the par-data    ###
###                                                        ###
##############################################################
##############################################################
#
#####################
try({
#####################
# LOOK FOR INPUT-PARAMETERFILE AND SET PARAMETERS
if (INPUT_PAR_FILE != "" && file.exists(INPUT_PAR_FILE)){
    parFileReport<-1            # Error handling - not yet realised
    PARS<-read.csv(INPUT_PAR_FILE,header=FALSE,sep=";",dec=".")

##############################################################

    cat("assingment of variabels (2.) ....\n")

##############################################################
    dataname<-as.character(PARS[1,1])               # name of csv-datafile
    head<-as.character(PARS[2,1])                   # header TRUE/FALSE
    head<-ifelse(head=="TRUE",TRUE,FALSE)
    c2<-as.character(PARS[3,1])                     # column of measurand
    c1<-as.character(PARS[4,1])                     # column of age
    c3<-as.character(PARS[5,1])                     # column of gender
    a1<-as.numeric(as.character(PARS[6,1]))         # min age
    a2<-as.numeric(as.character(PARS[7,1]))         # max age
    m<-as.character(PARS[8,1])                      # male character
    f<-as.character(PARS[9,1])                      # female character
    com<-as.numeric(as.character(PARS[10,1]))       # number of decimal places of measurand
    dec.sep<-as.character(PARS[11,1])               # decimal separator
    quant<-as.numeric(as.character(PARS[12,1]))     # quantiles 
    model<-as.character(PARS[13,1])                 # model 
    nmc<-as.numeric(as.character(PARS[14,1]))       # number of MC simulations for estimation of KS-distance
    pathol<-as.character(PARS[15,1])                # pathological value low/high/low+high=both
    x1<-as.numeric(as.character(PARS[16,1]))        # min value of x-axis
    x2<-as.numeric(as.character(PARS[17,1]))        # max value of x-axis
    c4<-as.character(PARS[18,1])                    # column of hospitalized/ambulantory 
    hospit<-as.character(PARS[19,1])                # denotation of hospitalized/ambulantory
    alpha1<-as.numeric(as.character(PARS[20,1]))    # value of alpha error for the test statistic
    testvalue<-as.character(PARS[21,1])             # name of measurand/quantity
    ci<-as.character(PARS[22,1])                    # confidence intervals TRUE/FALSE
    nrep<-as.numeric(as.character(PARS[23,1]))      # number of bootstraps for CI
    l0<-as.numeric(as.character(PARS[24,1]))        # min value of transformation parameter 
    n<-as.numeric(as.character(PARS[25,1]))         # start value of transformation parameter
    minsize<-as.numeric(as.character(PARS[26,1]))   # min of sample size in each group
    flag_file<-as.character(PARS[27,1])             # result.txt used as flag-file 
#   main_folder<-as.character(PARS[28,1])           # no fuction - free to use!
    file_prog<-as.character(PARS[29,1])             # subdirectory program
    file_res<-as.character(PARS[30,1])              # subdirectory results
    file_temp<-as.character(PARS[31,1])             # subdirectory temp 
    main_folder1<-as.character(PARS[32,1])          # absolute path of main folder of this tool (slash)
    stat_test<-as.character(PARS[33,1])             # statistical test TRUE/FALSE
    graph_format<-as.character(PARS[34,1])          # fomrat of graphics (BMP or JPG)
    error_file<-as.character(PARS[35,1])            # absolute path and filename of error file
    #savename1<-as.character(PARS[36,1])            # not used in prgram2! absolute path and filename for result1 file in program1
    savename2<-as.character(PARS[37,1])             # absolute path and filename for result2 file - only used in program2
    r_func<-as.character(PARS[38,1])                # absolute path for r functions   
    testunit<-as.character(PARS[39,1])              # unit of testvalue (for praphical output)
    #  group<-as.character(PARS[40,1])              # defines subgroups to evaluate: n.d.
    c5<-as.character(PARS[41,1])                    # column of date of test
    c6<-as.character(PARS[42,1])                    # format of date of test
    date1<-as.character(PARS[43,1])                 # start date of data to be analysed 
    date2<-as.character(PARS[44,1])                 # end date of data to be analysed
    p.U<-as.character(PARS[45,1])                   # permissable uncertainty TRUE/FALSE
    p.U<-ifelse(p.U=="TRUE",TRUE,FALSE) 
    file_data<-as.character(PARS[46,1])             # subdirectory for data (identically with temp if standard dataset used)
#############################################
   }
##############################################
# definition of path and files
par_file<-paste(main_folder1,"/",file_temp,"/", sep="")   # directory of par and data
data_file<-paste(main_folder1,"/",file_data,"/", sep="")  # subdirectory of data (for classic only)
result_file<-paste(main_folder1,"/",file_res,"/", sep="") # directory of results
prog_file<-paste(main_folder1,"/",file_prog,"/", sep="")  # directory of prog
##############################################
# create subfolders in folder \results to save the results and graphs. 
testvalue<-gsub('([[:punct:]])|\\s','_',testvalue)        # replace special symobols ($, &, /, etc. and empty spaces) with underline (_). 
result_file0<-paste(result_file, testvalue,"age",a1,a2, "date",format(Sys.time(), "%Y-%m-%d"), sep = "_") 
dir.create(result_file0, showWarnings = TRUE)
result_file1<-paste(result_file0 , "/","step2", sep = "")
dir.create(result_file1, showWarnings = TRUE)
##############################################
num.sink <- sink.number()
if (num.sink > 0)  for (i in 1:num.sink)  sink() 
logdat<-paste(main_folder1,"/",file_temp,"/RLE_Prog2.log", sep="")
}) 
errmess<-geterrmessage() 
if (errmess!="") {            
   errmess<-"error: the entries in tab parameter for analysis in start dialog box are not defined, completely or correctely. Or the user has no admin permission to create subfolders"
sink(file=logdat,append=FALSE, split=TRUE,type = c("output","message"))
end.time <- date()
cat("Program start:", start.time,"\n")
cat("program end:  ", end.time,"\n")
cat("================================================================\n\n")
cat(errmess, "\n")
sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }                                                            
###############################################################
if (a1 > a2) {            
   errmess<-"error: minimum age can not be greater than its maximum!"
   sink(file=logdat,append=FALSE, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }  
###############################################################
###                                                         ###
###               3. read of data                           ###
###                                                         ###
###############################################################
###############################################################

cat("read of data (3.) ....\n")
################################################
{
if (length(PARS[1,])==1){      # if only one data should be analysed
   file.name<-paste(data_file,dataname, sep="")
   check<-1
   suppressWarnings(data<-try(read.table(file=file.name,dec=dec.sep,header=head,sep=";"), TRUE))
   if (class(data) == "try-error") {
      errmess<-"error: either data set does not exist, or entries in parameter for analysis are not defined correctely or data in each line are not separated by ; or entries have not the same class."
      write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
      quit(save = "no", status = 0, runLast = FALSE)
      }else{
      data<-read.table(file=file.name,dec=dec.sep,header=head,sep=";")
      }
      }else{
      # if more than one data should be analysed
      dataname<-PARS[1,]
      J<-length(dataname)
      data<-NULL
      for (j in 1:J) {
         check<-2
         dataname1<-dataname[[j]]
         file.name<-paste(data_file,dataname1, sep="")
         suppressWarnings(data1<-try(read.table(file=file.name,dec=dec.sep,header=head,sep=";"), TRUE))
         if (class(data1) == "try-error") {
            errmess<-"error: either data set does not exist, or entries in parameter for analysis are not defined correctely or data in each line are not separated by ; or entries have not the same class."
            write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
            write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
            quit(save = "no", status = 0, runLast = FALSE)
            }else{
            data1<-read.table(file=file.name,dec=dec.sep,header=head,sep=";")
            suppressWarnings(data<-try(rbind(data,data1),TRUE))
            if (class(data) == "try-error") {
               errmess<-"error: the datasets have different structure and they can not be analysed together"
               write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
               write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
               quit(save = "no", status = 0, runLast = FALSE)
               }
            }
         }
      }
}
####################################
################################################
# rename of columns of data from letters to niumeric (e.g. C into 3)
nw<-ncol(data)
v1<-c(LETTERS[1:nw])
v2<-c(1:nw)
mat<-matrix(c(v1,v2),nrow=2,byrow=TRUE)
c1<-as.numeric(mat[,mat[1,]==c1][2])
c2<-as.numeric(mat[,mat[1,]==c2][2])
c3<-as.numeric(mat[,mat[1,]==c3][2])
c4<-as.numeric(mat[,mat[1,]==c4][2])
c5<-as.numeric(mat[,mat[1,]==c5][2])
if (!is.na(c4)) {
   data<-subset(data,subset=(data[,c4]==hospit))
   mycol<-c(c3,c4)
   for (i in mycol){ # columns for sex and station are redefined, that
                     # causes e.g. all rows with entries "M" or "M " or "M  " transfered to "M".  
      data[,i] <- gsub(" ", "", data[,i])
      }
   }else{
   data[,c3] <- gsub(" ", "", data[,c3])
   }
###############################################
## source of functions:
try(library(msm))
try(library(geoR))
errmess<-geterrmessage()                                                                       # test whether required packages exist.
if (errmess=="") { 
   errmess<-"no error"
   write.csv(errmess, file=error_file,quote=FALSE,row.names = FALSE)
   } else {
   sink(file=logdat,append=FALSE, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
cat("all libraries loaded ....\n")                  
################################################
# test whether the necessary columns are defined:
if (!is.na(c1) & !is.na(c2) & !is.na(c3)) {
   errmess<-"no error"
   write.csv(errmess, file=error_file,quote=FALSE,row.names = FALSE)
   } else {
   errmess<-"error: the columns of value, age or sex are not defined"
   sink(file=logdat,append=FALSE, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
################################################
####################################################
####################################################
# functions from prog subdirectories are now loaded:
try({
source(paste(r_func,"/data_sep1.R",sep=""))
source(paste(r_func,"/data_gr.R",sep=""))
source(paste(r_func,"/kde.R",sep=""))
source(paste(r_func,"/kde1.R",sep=""))
source(paste(r_func,"/graph_hist.R",sep="")) 
source(paste(r_func,"/data_sep.R",sep=""))
source(paste(r_func,"/data_gr.R",sep=""))
source(paste(r_func,"/kde.R",sep=""))
source(paste(r_func,"/kde1.R",sep=""))
source(paste(r_func,"/graph_hist.R",sep=""))
source(paste(r_func,"/T2point.R",sep=""))
source(paste(r_func,"/TNorm.R",sep=""))
source(paste(r_func,"/est_tpn.R",sep=""))
source(paste(r_func,"/est_dtpn0.R",sep=""))
source(paste(r_func,"/est_dtpn1.R",sep=""))
source(paste(r_func,"/est_dtpn2.R",sep=""))
source(paste(r_func,"/KD_tnorm.R",sep=""))
source(paste(r_func,"/KD_tnorm1.R",sep=""))
source(paste(r_func,"/KD_tnorm2.R",sep=""))
source(paste(r_func,"/area.R",sep=""))
source(paste(r_func,"/DL_pnm.R",sep=""))
source(paste(r_func,"/DL_log.R",sep=""))
source(paste(r_func,"/RLs.R",sep=""))
source(paste(r_func,"/gr_all0.R",sep=""))
source(paste(r_func,"/gr_est0.R",sep=""))
source(paste(r_func,"/rtboxcox.R",sep=""))
source(paste(r_func,"/sim_rtpn.R",sep=""))
source(paste(r_func,"/KS_rtpn_th.R",sep=""))
source(paste(r_func,"/KS_rtpn_test.R",sep=""))
source(paste(r_func,"/plot_wrapper.R",sep=""))
source(paste(r_func,"/pU.R",sep=""))
})
errmess<-geterrmessage() 
if (errmess!="") {                #   test whether required functions exist.     
   errmess<-"error: one or more required functions to analyse the data could not be loaded. Either subdirectory R functions has not been set correctly or some functions are removed. Create R functions again."
   sink(file=logdat,append=FALSE, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE,row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
####################################################
sink(file=logdat,append=FALSE, split=TRUE,type = c("output","message"))
cat("================================================================\n\n")
cat("Data have been imported correctly.","\n\n")
cat("================================================================\n\n")
sink()
cat("all functions loaded ....\n")
############################################
cat("program is running ....\n\n")
if (is.na(testvalue)) {
    testvalue<-""
   }
######################################################################
#########################
# Time limitation of data:
#########################
try({
  if(!is.na(date1)) date1<-as.Date(date1,,format=c6)
  if(!is.na(date2)) date2<-as.Date(date2,,format=c6)
  }) 
errmess<-geterrmessage() 
if (errmess!="") {            
  errmess<-"error: choosed formats for start or end date are false. You can set start and end date by NA"
   sink(file=logdat,append=T, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
###############################################
if (!is.na(date1) & !is.na(date2) & date1 >= date2 ) {            
errmess<-"error: start date can not be greater as end date! You can set start and end date by NA"
sink(file=logdat,append=T, split=TRUE,type = c("output","message"))
end.time <- date()
cat("Program start:", start.time,"\n")
cat("program end:  ", end.time,"\n")
cat("================================================================\n\n")
cat(errmess, "\n")
sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
################
case<-0
try({
  if (!is.na(c5) & !is.na(c6) &  !is.na(date1)) {
    data[,c5]<-as.Date(data[,c5], format=c6)# appended format for date of analysis 
    date1<-as.Date(date1,format=c6)
    data1<-subset(data,subset=(data[,c5] >= date1))
    len.1<-nrow(data1)
    if (len.1!=0 & !is.na(len.1)){
      case<-1
      sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
      cat("================================================================\n\n")
      cat("Time of analysis has been limited to the given start date.","\n\n")
      cat("================================================================\n\n")
      sink()
      data<-data1
      }else{
      errmess<-"error: either choosed format for date or column of date or given start date are not given correctly. Program was run without consider start date."
      sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
      cat("================================================================\n\n")
      cat(errmess, "\n")
      sink()
      }
    }else{
    sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
    cat("================================================================\n\n")
    cat("either start date is not given or no information about date of analysis exists or choosed format/column for date or start date are not given correctly\n")
    cat("Program is running without considering start date.","\n\n")
    cat("================================================================\n\n")
    sink()          
    }
 }, silent = TRUE) 
 #########################
case<-0
try({
  if (!is.na(c5) & !is.na(c6) &  !is.na(date2)) {
    data[,c5]<-as.Date(data[,c5], format=c6)# appended format for date of analysis 
    date2<-as.Date(date2,format=c6)
    data1<-subset(data,subset=(data[,c5] <= date2))
    len.1<-nrow(data1)
    if (len.1!=0 & !is.na(len.1)){
      case<-1
      sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
      cat("================================================================\n\n")
      cat("Time of analysis has been limited to the given end date.","\n\n")
      cat("================================================================\n\n")
      sink()
      data<-data1
      }else{
      errmess<-"error: either choosed format for date or column of date or given end date are not given correctly. Program was run without consider end date."
      sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
      cat("================================================================\n\n")
      cat(errmess, "\n")
      sink()
      }
    }else{
    sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
    cat("================================================================\n\n")
    cat("either end date is not given or no information about date of analysis exists or choosed format/column for date or end date are not given correctly\n")
    cat("Program is running without considering end date","\n\n")
    cat("================================================================\n\n")
    sink()          
    }
 }, silent = TRUE)   
######################################################################
###                                                                ###
###   4. make summary statistics and kernel density estimations    ###
###                                                                ###
######################################################################
######################################################################
#
# data.sep function gives the test values of subjects in given age range for different gender separately.
#
cat("make summary statistics and kernel density estimations (4.) ...\n")
try({
d<-data.sep(data=data,c1=c1,c2=c2,c3=c3,a1=a1,a2=a2,m=m,w=f)
n1<-length(d$all)
n2<-length(d$m)
n3<-length(d$w)
})
#####################################################################
errmess<-geterrmessage() 
if (errmess!="" | n1==0 | n2==0 | n3==0) {            
   errmess<-"error: either the columns of value, age or sex do not exist/defined correctely or denotation of sex is not correctly or dataset does not contain male and female results or limits of ages are not given correctly."
   sink(file=logdat,append=T, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
######### data.gr gives summary statistics of data
try({
d<-data.gr(data=data,c1=c1,c2=c2,c3=c3,a1=a1,a2=a2,m=m,w=f)

dbm<-d$all  # values for male+female subjects (age group: a1<= age <= a2)
dmbm<-d$m   # values for male subjects (age group: a1<= age <= a2)
dwbm<-d$w   # values for female subjects (age group: a1<= age <= a2)
})
errmess<-geterrmessage() 
if (errmess!="" | !is.numeric(dmbm) | !is.numeric(dwbm) | !is.numeric(dbm)) {            
   errmess<-"error: either the columns of value, age or sex do not exist/defined correctely or denotation of sex is not correctly or dataset does not contain male and female results or limits of ages are not given correctly."
   sink(file=logdat,append=T, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
######################################################################
if (length(dmbm) < 2 | length(dwbm) < 2) {            
   errmess<-"error: the sample size is small. Try with more data points or wider age range."
   sink(file=logdat,append=T, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
#####################################################################
######################
if (length(dmbm) > 40000){
   bw1<-bw.nrd(dmbm)
   }else{                                
   bw1<-try(bw.SJ(dmbm,method="dpi"),silent=T)
   if (class(bw1) == "try-error") { 
     bw1<-bw.nrd(dmbm)
     }
   }
if (length(dwbm) > 40000){
   bw2<-bw.nrd(dwbm)
   }else{ 
   bw2<-try(bw.SJ(dwbm,method="dpi"),silent=T)
   if (class(bw2) == "try-error") {
      bw2<-bw.nrd(dwbm)
      }
   }
if (length(dbm) > 40000){
   bw0<-bw.nrd(dbm)
   }else{       
   bw0<-try(bw.SJ(dbm,method="dpi"),silent=T)
   if (class(bw0) == "try-error") {            
      bw0<-min(bw.nrd(dbm),bw1,bw2)
      }
   }              
######################################################################
bw0<-round(bw0,com)
bw1<-round(bw1,com)
bw2<-round(bw2,com)
step0<-(10^(-com))
bwa<-max(bw0,(step0)/2) # bandwidth of kde for all data
bwm<-max(bw1,(step0)/2) # bandwidth of kde for male
bww<-max(bw2,(step0)/2) # bandwidth of kde for female
if ( bwa <=0 | bwm <=0 | bww <=0 | is.na(bwa) | is.na(bwm) | is.na(bww)) {
   errmess<-"error: bandwidths could not be estimated. Try with more data points"
   sink(file=logdat,append=T, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }
#########################
stepa<-max(bw0,step0)
###########################
stepm<-max(bw1,step0)
###############
stepw<-max(bw2,step0)
###############################################
mean1<-round(mean(dbm),com)
sd1<-round(sd(dbm),com)
if (x1==0) {
    x1<-max(round(mean1-4*sd1,com),0)
   }
if (x2==0 | x2 <= x1) {
    x2<-round(mean1+4*sd1,com)
   }
T<-10*(mean1+2*sd1)
#########################################
#########################################
# updated: 03.09.2014 for graphical display
# of estimations. 
#
dbm<-dbm[dbm<=T]
dmbm<-dmbm[dmbm<=T]
dwbm<-dwbm[dwbm<=T]
#########################################
#########################################
modm<-kde(data=dmbm,nb=900,q1=0,bw0=bwm)$u
modm<-round(modm,2)
modw<-kde(data=dwbm,nb=900,q1=0,bw0=bww)$u
modw<-round(modw,2)
mod<-kde(data=dbm,nb=900,q1=0,bw0=bwa)$u
mod<-round(mod,2)
#######################################
# dmbm,dwbm and dbm are now transformed data, and dmbm1,dwbm1,dbm1 not transformed data.
# modm, modw and mod are transformed mods, and modm1, modw1  mod1 not transformed mods.
#######################################
h0<-c("male","female","all")
h0.age<-rep(paste(a1,"-",a2),3)
h1<-c(n2,n3,n1)
h2<-c(modm,modw,mod)
p1<-p2<-p3<-NA
mu1<-mu2<-mu3<-NA
sig1<-sig2<-sig3<-NA
lam1<-lam2<-lam3<-NA
LR1<-LR2<-LR3<-NA
UR1<-UR2<-UR3<-NA
KSemp1<-KSemp2<-KSemp3<-NA
KSth1<-KSth2<-KSth3<-NA
pvalue1<-pvalue2<-pvalue3<-NA
mLRL1<-wLRL1<-LRL1<-NA
mLRL2<-wLRL2<-LRL2<-NA
mURL1<-wURL1<-URL1<-NA
mURL2<-wURL2<-URL2<-NA
h3<-c(p1,p2,p3)
h4<-c(mu1,mu2,mu3)
h5<-c(sig1,sig2,sig3)
h6<-c(lam1,lam2,lam3)
h7<-c(LR1,LR2,LR3)
h8<-c(UR1,UR2,UR3)
h10<-c(KSemp1,KSemp2,KSemp3)
h11<-c(KSth1,KSth2,KSth3)
h12<-c(pvalue1,pvalue2,pvalue3)
h13<-c(mLRL1,wLRL1,LRL1)
h14<-c(mLRL2,wLRL2,LRL2)
h15<-c(mURL1,wURL1,URL1)
h16<-c(mURL2,wURL2,URL2)
############################
mpU.LRL1<-wpU.LRL1<-pU.LRL1<-NA # Low-permissable uncertainty for low-RLs 
mpU.LRL2<-wpU.LRL2<-pU.LRL2<-NA # Upper-permissable uncertainty for low-RLs
mpU.URL1<-wpU.URL1<-pU.URL1<-NA # Low-permissable uncertainty for upper-RLs
mpU.URL2<-wpU.URL2<-pU.URL2<-NA # Upper-permissable uncertainty for upper-RLs
h17<-c(mpU.LRL1,wpU.LRL1,pU.LRL1)
h18<-c(mpU.LRL2,wpU.LRL2,pU.LRL2)
h19<-c(mpU.URL1,wpU.URL1,pU.URL1)
h20<-c(mpU.URL2,wpU.URL2,pU.URL2)
############################
d<-data.frame(h0,h0.age,h1,h2,h3,h4,h5,h6,h7,h8,h17,h18,h19,h20,h10,h11,h12,h13,h14,h15,h16)
colnames(d)<-c("Pop.","Age","N","Mode","P","mu","sigma","lambda","lower RL","upper RL","L-pU-LRL","U-pU-LRL","L-pU-RRL","U-pU-RRL","Test value","Critical value","P value","L-LRL","U-LRL","L-RRL","U-RRL")
#####################################################################
#####################################################################
###                                                                ##
###   5. estimation of distribution of non-pathological values     ##
###                                                                ##
#####################################################################
#####################################################################
cat("estimation of distribution of non-pathological values is running (5.)....\n")
#
nen<-1          # factor to modify start value of sigma for estimation
dif1<-1         # factor to modify truncation point

#################################################
###### assignment of minimum/maximum of trunction points and the range of lambda which will be searched.
alpha1<-alpha1/100
#################################################
# This part of program automate the choice of option "pathological values", if this is not 
# given by user:
if ((pathol!="H" & pathol!="L" & pathol!="B") | is.na(pathol))   {
   nm.A<-length(dmbm)  
   nw.A<-length(dwbm)  
   nm.L<-length(dmbm[dmbm<modm]) 
   nw.L<-length(dwbm[dwbm<modw])
   if ((nm.L+nw.L)/(nm.A+nw.A) < 1/2){
      pathol<-"H"
      }else{
      pathol<-"L"
      }
   }  
if (pathol!="H" & pathol!="L" & pathol!="B") {
   errmess<-"error: set option pathological values as NA"
   sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat(errmess, "\n")
   sink()
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE)
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE)
   quit(save = "no", status = 0, runLast = FALSE)
   }                                                                  
##################
if (pathol=="H"){               # if pathological values are expected to be high values
   Q1<-0.05
   Q2<-0.85
   } else if (pathol=="L"){     # if pathological values are expected to be low values
   Q1<-0.15
   Q2<-0.95
   } else {                     # if pathological values are expected to be low and high values
   Q1<-0.10
   Q2<-0.90
   }
if (model=="PN"){
            # Power normal distr. uses Box-Cox transformation
            # to achieve Gaussian dist.
   l0<-l0
   n<-n
   min1<-0
   min2<-0
   min3<-0
   dmbm1<-dmbm
   dwbm1<-dwbm
   dbm1<-dbm
   dmbm<-dmbm1-min1
   dwbm<-dwbm1-min2
   dbm<-dbm1-min3
   modm1<-modm
   modw1<-modw
   mod1<-mod
   modm<-modm1-min1
   modw<-modw1-min2
   mod<-mod1-min3
   if (n==1){
      lstep<-0
      nstep<-1
      } else{
      lstep<-0.1
      nstep<-21
      }
   } else if (model=="G"){
   # Gaussian distr. as model
   l0<-1
   n<-1
   min1<-0
   min2<-0
   min3<-0
   dmbm1<-dmbm
   dwbm1<-dwbm
   dbm1<-dbm
   dmbm<-dmbm1-min1
   dwbm<-dwbm1-min2
   dbm<-dbm1-min3
   modm1<-modm
   modw1<-modw
   mod1<-mod
   modm<-modm1-min1
   modw<-modw1-min2
   mod<-mod1-min3
   lstep<-0
   nstep<-1
   } else {
   # modified power normal (MPN) distribution as default.
   # Modified power normal distr. uses modified Box-Cox transformation,
   # a more flexible way to achieve Gaussian dist.
   # For more details see Ichihara et al.
   l0<-l0
   n<-n
   min1<-min(dmbm)
   min2<-min(dwbm)
   min3<-min(dbm)
   dmbm1<-dmbm
   dwbm1<-dwbm
   dbm1<-dbm
   dmbm<-dmbm1-min1
   dwbm<-dwbm1-min2
   dbm<-dbm1-min3
   modm1<-modm
   modw1<-modw
   mod1<-mod
   modm<-modm1-min1
   modw<-modw1-min2
   mod<-mod1-min3
   if (n==1){
      lstep<-0
      nstep<-1
      } else{
      lstep<-0.1
      nstep<-21
      }
   }
#####################
## max.TR limits the maximum of truncation points                    
max.TRm<-4*(modm1-min(dmbm1))+modm1
max.TRw<-4*(modw1-min(dwbm1))+modw1
max.TR<-4*(mod1-min(dbm1))+mod1
#########################################################################
##                                                                     ##
## 5.H.   if pathological values are expected to be only high values   ##
##                                                                     ##
#########################################################################
errm<-errm1<-errm2<-errw<-errw1<-errw2<-erra<-erra1<-erra2<-"no error"
# for Gender=m (male), = w (female) and =a (all), and for three subprogramms
# (estimation of RL, P-Values and confidence intervals) are three
# error variables defined, which control programm courses.
#########################################################################
if (pathol=="H"){   # if pathological values are expected to be only high values
   cat("pathological = high (5.H.)....\n")
####################################################
######    now estimation for male subjects
####################################################
cat("Estimation of RL for male subjects (5.H.male)....   \n")
   try({
   TLm<-round(quantile(dmbm,Q1),com)
   if (max.TRm > modm1){
      TR2m<-round(min(quantile(dmbm,Q2),max.TRm),com)
      }else{
      TR2m<-round(quantile(dmbm,Q2),com) 
      } 
   est<-est.dtpn2(d=dmbm,l0=l0,sl=0.1,n=n,TL=TLm,mod=modm,com=com,c2=dif1,TR2=TR2m,nen=nen)
   est1<-est$y0
#########################
   qstep<-0.01
   q10<-Q1
   while (est1[1,12]==1 && qstep <=q10) {     # if the truncated part is too narrow, it will be boarder.
      q10<-round(q10-qstep,2)
      TLm<-round(quantile(dmbm,q10),com)
      est<-est.dtpn2(d=dmbm,l0=l0,sl=0.1,n=n,TL=TLm,mod=modm,com=com,c2=dif1,TR2=TR2m,nen=nen)
      est1<-est$y0
      }
################################
   if (est1[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
      estim.m<-p1<-mu1<-sig1<-lam1<-LR1<-UR1<-q10m<-TLm<-TR1m<-0
      bild4<-paste(result_file,"est_male",sep="")
      bild4.1<-paste(result_file1,"/","est_male.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild4,width=7,height=5)
      plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
      text(6,2,"No estimation for male subjects",cex=2,col="red")
      abline(0,0)
      close_plot(graph_format=graph_format,file=bild4)
      close_plot(graph_format=graph_format,file=bild4.1)
      } else {
      estim.m<-1
      l<-est1[8]
      TLm<-est1[3]
      TR1m<-est1[4]
      #### final estimation for male subjects (accuaracy of lambda: 0.01):
      est<-est.dtpn2(d=dmbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TL=TLm,mod=modm,com=com,TR1=TR1m,TR2=TR1m,nen=nen)
      q10m<-q10
      lambda1<-est$y0[8]
      #########################
      tm<-RLs(est=est,com=com) # calculates RLs
      estm<-est
      p1<-estm$y0[1,5]
      mu1<-estm$y0[1,6]
      sig1<-estm$y0[1,7]
      lam1<-estm$y0[1,8]
      LR1<-tm$RLL1+min1
      UR1<-tm$RLR1+min1
      ######################################################
      ######################################################
      # step4- graphical display of estimations
      # Description of function gr.est below:
      # display the estimated distributions for pathological and non-pathological values 
      # est: estimated distribution above
      # x01 and x02: limits of  x-axis inthe figure
      # step0: estimated banwidth above
      # com:  indicates the number of decimal places (see above)
      # low: lower limit to calculate the pathological density funtion. Default=mod of the data estimated above, then
      # it is assumed that all values below the mod of data stem from non-pathological values
      ###################################
      bild4<-paste(result_file,"est_male.",graph_format,sep="")
      bild4.1<-paste(result_file1,"/","est_male.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild4,width=7,height=5)
      zm<-gr.est0(data=dmbm,est=estm,x02=x2,x01=x1,step0=stepm,bw=bwm,com=com,labx=paste(testvalue," ",testunit),low=TLm,high=TR1m,main="male",lam2=min1)
      close_plot(graph_format=graph_format,file=bild4)
      close_plot(graph_format=graph_format,file=bild4.1)
      }
}, silent = TRUE)  # end of try
##################################
##################################
if (estim.m==0)  {    
   p1<-mu1<-sig1<-lam1<-LR1<-UR1<-NA       
   errm<-"error: distribution of non-path. values for male subjects could not be separated from the whole data. Try option path=L or path=B"
   }
if (estim.m!=0 & p.U==TRUE)  {
   est.pU1<-pU(x=LR1,RL1=LR1,RL2=UR1,com=com+1)
   mpU.LRL1<-est.pU1[[1]]
   mpU.LRL2<-est.pU1[[2]]
   rm(est.pU1)
   est.pU2<-pU(x=UR1,RL1=LR1,RL2=UR1,com=com+1)
   mpU.URL1<-est.pU2[[1]]
   mpU.URL2<-est.pU2[[2]]
   rm(est.pU2)
   } else {        # if  p.U==FALSE   no calculation n.d. = not done 
   mpU.LRL1<-mpU.LRL2<-mpU.URL1<-mpU.URL2<-"n.d."
   }
####################################################
######    now estimation for female:
####################################################
cat("Estimation of RL for female subjects  (5.H.female)....   \n")
try({
   TLw<-round(quantile(dwbm,Q1),com)
   if (max.TRw > modw1){
      TR2w<-round(min(quantile(dwbm,Q2),max.TRw),com)
      }else{
      TR2w<-round(quantile(dwbm,Q2),com) 
      } 
   est<-est.dtpn2(d=dwbm,l0=l0,sl=0.1,n=n,TL=TLw,mod=modw,com=com,c2=dif1,TR2=TR2w,nen=nen)
   est1<-est$y0
###########################
   qstep<-0.01
   q10<-Q1
   while (est1[1,12]==1 && qstep <=q10){
      q10<-round(q10-qstep,2)
      TLw<-round(quantile(dwbm,q10),com)
      est<-est.dtpn2(d=dwbm,l0=l0,sl=0.1,n=n,TL=TLw,mod=modw,com=com,c2=dif1,TR2=TR2w,nen=nen)
      est1<-est$y0
      }
   ##########################
   if (est1[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
      estim.w<-p2<-mu2<-sig2<-lam2<-LR2<-UR2<-q10w<-TLw<-TR1w<-0
      bild5<-paste(result_file,"est_female.",graph_format,sep="")
      bild5.1<-paste(result_file1,"/","est_female.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild5,width=7,height=5)
      plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
      text(6,2,"No estimation for female subjects",cex=2,col="red")
      abline(0,0)
      close_plot(graph_format=graph_format,file=bild5)
      close_plot(graph_format=graph_format,file=bild5.1)
      } else {
      ######################
      estim.w<-1
      l<-est1[8]
      TLw<-est1[3]
      TR1w<-est1[4]
      est<-est.dtpn2(d=dwbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TL=TLw,mod=modw,com=com,TR1=TR1w,TR2=TR1w,nen=nen)
      lambda2<-est$y0[8]
      q10w<-q10
      tw<-RLs(est=est,com=com) # calculates RLs
      estw<-est
      p2<-estw$y0[1,5]
      mu2<-estw$y0[1,6]
      sig2<-estw$y0[1,7]
      lam2<-estw$y0[1,8]
      LR2<-tw$RLL1+min2
      UR2<-tw$RLR1+min2
      ######################################################
      bild5<-paste(result_file,"est_female.",graph_format,sep="")
      bild5.1<-paste(result_file1,"/","est_female.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild5,width=7,height=5)
      zw<-gr.est0(data=dwbm,est=estw,x02=x2,x01=x1,step0=stepw,bw=bww,com=com,labx=paste(testvalue," ",testunit),low=TLw,high=TR1w,main="female",lam2=min2)
      close_plot(graph_format=graph_format,file=bild5)
      close_plot(graph_format=graph_format,file=bild5.1)
      }
}, silent = TRUE)  # end of try
##################################
if (estim.w==0){ 
   p2<-mu2<-sig2<-lam2<-LR2<-UR2<-NA            
   errw<-"error: distribution of non-path. values for female subjects could not be separated from the whole data. Try option path=L or path=B"
   }
if (estim.w!=0 & p.U==TRUE) {
   est.pU1<-pU(x=LR2,RL1=LR2,RL2=UR2,com=com+1)
   wpU.LRL1<-est.pU1[[1]]
   wpU.LRL2<-est.pU1[[2]]
   rm(est.pU1)
   est.pU2<-pU(x=UR2,RL1=LR2,RL2=UR2,com=com+1)
   wpU.URL1<-est.pU2[[1]]
   wpU.URL2<-est.pU2[[2]]
   rm(est.pU2)
   } else {        # if  p.U==FALSE   no calculation n.d. = not done 
   wpU.LRL1<-wpU.LRL2<-wpU.URL1<-wpU.URL2<-"n.d."
   }
############################################
######    now for all (men+women):
############################################
    cat("Estimation of RL for all subjects   (5.H.all)......   \n")
    try({
    Nmin<-minsize
    TLa<-round(quantile(dbm,Q1),com)
    if (max.TR > mod1){
       TR2a<-round(min(quantile(dbm,Q2),max.TR),com)
       }else{
       TR2a<-round(quantile(dbm,Q2),com) 
       } 
    if (estim.w != 0 & estim.m != 0 & min(n1,n2,n3) >=Nmin){ 
       TR1m1<-TR1m+min1  # not transformed optimala truncation point for male
       TR1w1<-TR1w+min2  # not transformed optimala truncation point for female
       TR2a1<-TR2a+min3  # the first limit for trunction point for male+females
       Trr1<-min(TR1m1,TR1w1)
       Trr2<-max(TR1m1,TR1w1)
       tr1<-min(Trr1,TR2a1)-min3
       tr2<-min(Trr2,TR2a1)-min3
       qstep<-0.01
       lmin<-min(lambda1,lambda2)
       lmax<-max(lambda1,lambda2)
       nall<-(lmax-lmin)*100+1
       est<-est.dtpn2(d=dbm,l0=lmin,sl=0.01,n=nall,TL=TLa,mod=mod,com=com,TR1=tr1,TR2=tr2,nen=nen)
       est1<-est$y0
       qstep<-0.01
       q10<-Q1
       while (est1[1,12]==1 && qstep <=q10){
             q10<-round(q10-qstep,2)
             TLa<-round(quantile(dbm,q10),com)
             est<-est.dtpn2(d=dbm,l0=lmin,sl=0.01,n=nall,TL=TLa,mod=mod,com=com,TR1=tr1,TR2=tr2,nen=nen)
             est1<-est$y0
             }
################################
       if (est1[1,12]==1) {   # if no proper truncation points are found the program is stopped!!
          estim.a<-0
          bild6<-paste(result_file,"est_all.",graph_format,sep="")
          bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")
          open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
          plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
          text(6,2,"No estimation for all subjects",cex=2,col="red")
          abline(0,0)
          close_plot(graph_format=graph_format,file=bild6)
          close_plot(graph_format=graph_format,file=bild6.1)
          } else {
          estim.a<-1
          TLa<-est1[3]
          TR1a<-est1[4]
          t<-RLs(est=est,com=com) # calculates RLs
          LR3<-t$RLL1+min3
          UR3<-t$RLR1+min3
          q10a<-q10
          bild6<-paste(result_file,"est_all.",graph_format,sep="")
          bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")          
          open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
          za<-gr.est0(data=dbm,est=est,x02=x2,x01=x1,step0=stepa,bw=bwa,com=com,labx=paste(testvalue," ",testunit),low=TLa,high=TR1a,main="all",lam2=min3)
          close_plot(graph_format=graph_format,file=bild6)
          close_plot(graph_format=graph_format,file=bild6.1)
          }
       } else {
       TLa<-round(quantile(dbm,Q1),com)
       est<-est.dtpn2(d=dbm,l0=l0,sl=0.1,n=n,TL=TLa,mod=mod,com=com,c2=dif1,TR2=TR2a,nen=nen)
       est1<-est$y0
       qstep<-0.01
       q10<-Q1
       while (est1[1,12]==1 && qstep <=q10) {
             q10<-round(q10-qstep,2)
             TLa<-round(quantile(dbm,q10),com)
             TR2a<-round(quantile(dbm[dbm>=TLa],Q2),com)
             est<-est.dtpn2(d=dbm,l0=l0,sl=0.1,n=n,TL=TLa,mod=mod,com=com,c2=dif1,TR2=TR2a,nen=nen)
             est1<-est$y0
             }
 ################################
       if (est1[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
          estim.a<-0
          bild6<-paste(result_file,"est_all",sep="")
          bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")
          open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
          plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
          text(6,2,"No estimation for all subjects",cex=2,col="red")
          abline(0,0)
          close_plot(graph_format=graph_format,file=bild6)
          close_plot(graph_format=graph_format,file=bild6.1)
          } else {
          estim.a<-1
          l<-est1[8]
          TLa<-est1[3]
          TR1a<-est1[4]
          est<-est.dtpn2(d=dbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TL=TLa,mod=mod,com=com,TR1=TR1a,TR2=TR1a,nen=nen)
          q10a<-q10
          t<-RLs(est=est,com=com) # calculates RLs
          LR3<-t$RLL1+min3
          UR3<-t$RLR1+min3
##################################
##################################
          bild6<-paste(result_file,"est_all.",graph_format,sep="")
          bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")
          open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
          za<-gr.est0(data=dbm,est=est,x02=x2,x01=x1,step0=stepa,bw=bwa,com=com,labx=paste(testvalue," ",testunit),low=TLa,high=TR1a,main="all",lam2=min3)
          close_plot(graph_format=graph_format,file=bild6)
          close_plot(graph_format=graph_format,file=bild6.1)
          }
       }
       if (estim.a==0) {
          p3<-mu3<-sig3<-lam3<-LR3<-UR3<-q10a<-TLa<-TR1a<-0
          } else {
          p3<-est$y0[1,5]
          mu3<-est$y0[1,6]
          sig3<-est$y0[1,7]
          lam3<-est$y0[1,8]
          }
}, silent = TRUE)  # end of try
##################################
##################################
if (estim.a==0){ 
   p3<-mu3<-sig3<-lam3<-LR3<-UR3<-NA            
   erra<-"error: distribution of non-path. values for all subjects could not be separated from the whole data"
   }
if (estim.a!=0 & p.U==TRUE){
   est.pU1<-pU(x=LR3,RL1=LR3,RL2=UR3,com=com+1)
   pU.LRL1<-est.pU1[[1]]
   pU.LRL2<-est.pU1[[2]]
   rm(est.pU1)
   est.pU2<-pU(x=UR3,RL1=LR3,RL2=UR3,com=com+1)
   pU.URL1<-est.pU2[[1]]
   pU.URL2<-est.pU2[[2]]
   rm(est.pU2)
   } else {        # if  p.U==FALSE   no calculation n.d. = not done 
   pU.LRL1<-pU.LRL2<-pU.URL1<-pU.URL2<-"n.d."
   }
##################################
if (estim.a==0 & estim.w==0 & estim.m==0){ 
   errmess<-"error: distribution of non-path. values could not be separated from the whole data. Set option pathological values = L (low) or = B (both).
          Read prog_log.txt data for more informations."
   sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
   end.time <- date()
   cat("Program start:", start.time,"\n")
   cat("program end:  ", end.time,"\n")
   cat("================================================================\n\n")
   cat("estimation of RLs:","\n")
   cat("male subjects:", errm , "\n")
   cat("female subjects:", errw , "\n")
   cat("all subjects:", erra , "\n\n")
   sink()
   ##################################
   ### copy in flag file and subfolder:
   write.table(d, file = flag_file,quote=F,sep=";",col.names=TRUE)
   write.csv(d, file = savename2,quote=F)
   Result2<-paste(result_file1,"/","result2.csv",sep="")
   write.csv(d, file = Result2,quote=F)
   write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n\n")
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n\n")
   quit(save = "no", status = 0, runLast = FALSE)
   }
###########################################################################
##                                                                       ##
## 5.H.stat testing the null hypothesis for the estimated distributions  ##
##        pathol==H                                                      ##
##                                                                       ##
###########################################################################
if (stat_test=="TRUE"){
   cat("testing the null hypothesis (5.H.stat.)....\n")
   ####################
   if (estim.m==0 | nmc <= 0){ 
      KSemp1<-KSth1<-pvalue1<- "n.d." 
      errm1<-"p-value will not be calculated for male subjects"
      cat("p-value will not be calculated for male subjects   (5.H.stat.male)    \n") 
      } else {
      cat("testing the null hypothesis for male subjects (5.H.stat.male)....\n")
      try({
         test<-KS.rtpn.test(data=dmbm,est=estm,n1=nmc,alpha1=alpha1,sl=0.01,
         m1=101,nen=nen,epsilon=1E-4,I=100,mod=modm,com=com)
         }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
         KSemp1<-KSth1<-pvalue1<- "n.d."          
         errm1<-"error: p-value could not be calculated for male subjects"
         } else {
         KSemp1<-round(test$KolmEmp,4)
         KSth1<-round(test$KDcr5,4)
         pvalue1<-test$px
         rm(test)
         } 
      }
   ################################
   if (estim.w==0 | nmc <= 0){ 
      KSemp2<-KSth2<-pvalue2<- "n.d." 
      errw1<-"p-value will not be calculated for female subjects" 
      cat("p-value will not be calculated for female subjects  (5.H.stat.female)  \n")
      } else {
      cat("testing the null hypothesis for female subjects (5.H.stat.female)....\n")
      try({
         test<-KS.rtpn.test(data=dwbm,est=estw,n1=nmc,alpha1=alpha1,sl=0.01,
         m1=101,nen=nen,epsilon=1E-4,I=100,mod=modw,com=com)
         }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
         KSemp2<-KSth2<-pvalue2<- "n.d."          
         errw1<-"error: p-value could not be calculated for female subjects"
         } else {
         KSemp2<-round(test$KolmEmp,4)
         KSth2<-round(test$KDcr5,4)
         pvalue2<-test$px
         rm(test)
         } 
      }
   #######################
   if (estim.a==0 | nmc <= 0){ 
      KSemp3<-KSth3<-pvalue3<- "n.d."
      erra1<-"p-value will not be calculated for all subjects"  
      cat("p-value will not be calculated for all subjects   (5.H.stat.all)   \n")
      } else {
      cat("testing the null hypothesis for all subjects (5.H.stat.all)....\n")
      try({
         test<-KS.rtpn.test(data=dbm,est=est,n1=nmc,alpha1=alpha1,sl=0.01,
         m1=101,nen=nen,epsilon=1E-4,I=100,mod=mod,com=com)
         }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
         KSemp3<-KSth3<-pvalue3<- "n.d."          
         erra1<-"error: p-value could not be calculated for all subjects"
         } else {
         KSemp3<-round(test$KolmEmp,4)
         KSth3<-round(test$KDcr5,4)
         pvalue3<-test$px
         rm(test)
         } 
      }     
   } else {
   cat("without testing the null hypothesis (5.H.stat.)....\n")
   # n.d. (not done) instead of content
   KSemp1<-KSemp2<-KSemp3<-KSth1<-KSth2<-KSth3<-pvalue1<-pvalue2<-pvalue3<-"n.d."
   }
######################################################
##                                                  ##
##  5.H.CI   calculating 90% confidence intervals   ##
##           pathol==H                              ##
##                                                  ##
######################################################
if (ci=="TRUE" & nrep > 0)    {
   cat("Calculating 90%-confidence intervals (5.H.CI.)....\n")
   mRLR<-mRLL<-wRLR<-wRLL<-RLR<-RLL<-c(rep(0,nrep)) 
   ################################################################################
   ##  if estimations for male, female and all subjects were successfully
   ################################################################################
   if (estim.a==1 & estim.w==1 & estim.m==1)  {      
      cat("Calculating 90%-confidence interval for male, female and all subjects   \n")
      try({
         j1<-1;
         while (j1<=nrep)  {
            datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
            if (model=="PN" | model=="G") {
               min1<-0
               } else {
               min1<-min(datasim11)
               }
            datasim1<-datasim11-min1
            TLmsam<-round(quantile(datasim1,q10m),com)
            TR2msam<-round(min(quantile(datasim1,Q2),max.TRm),com)
            bw1sam<-bw.nrd(datasim1)
            t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
            k1sam<-t1sam$y
            u1sam<-t1sam$x
            a.maxsam<-which.max(k1sam)
            mod0sam<-u1sam[a.maxsam]
            estsam<-est.dtpn2(d=datasim1,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
            est1sam<-estsam$y0
            #########################
            ## if no proper truncation points are found the program is stopped!!
            ################################
            if (est1sam[1,12]==1) {   
               mRLR[j1]<-mRLL[j1]<-0
               } else {
               lsam<-est1sam[8]
               TLmsam<-est1sam[3]
               TR1msam<-est1sam[4]
               estsam<-est.dtpn2(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1msam,TR2=TR1msam,nen=nen)
               lambda1sam<-estsam$y0[8]
               tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
               mRLL[j1]<-tmsam$RLL1+min1
               mRLR[j1]<-tmsam$RLR1+min1
               }         
            datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
            if (model=="PN" | model=="G") {
               min2<-0
               } else {
               min2<-min(datasim22)
               }
            datasim2<-datasim22-min2
            TLmsam<-round(quantile(datasim2,q10w),com)
            TR2msam<-round(min(quantile(datasim2,Q2),max.TRw),com)
            bw1sam<-bw.nrd(datasim2)
            t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
            k1sam<-t1sam$y
            u1sam<-t1sam$x
            a.maxsam<-which.max(k1sam)
            mod0sam<-u1sam[a.maxsam]
            estsam<-est.dtpn2(d=datasim2,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
            est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            wRLR[j1]<-wRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1wsam<-est1sam[4]
            ##############################################                           final estimation for female subjects (accuaracy of lambda: 0.01):
            estsam<-est.dtpn2(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1wsam,TR2=TR1wsam,nen=nen)
            lambda2sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            wRLL[j1]<-tmsam$RLL1+min2
            wRLR[j1]<-tmsam$RLR1+min2
            }
         min0<-min(min1,min2)
         datasim<-c(datasim11,datasim22)
         datasim<-datasim-min0
         TLasam<-round(quantile(datasim,q10a),com)
         TR2asam<-round(min(quantile(datasim,Q2),max.TR),com)
         TR1msam1<-TR1msam+min1  # not transformed optimala truncation point for male
         TR1wsam1<-TR1wsam+min2  # not transformed optimala truncation point for female
         TR2asam1<-TR2asam+min0  # the first limit for trunction point for male+females
         Trr1sam1<-min(TR1msam1,TR1wsam1)
         Trr2sam1<-max(TR1msam1,TR1wsam1)
         tr1sam<-min(Trr1sam1,TR2asam1)-min0
         tr2sam<-min(Trr2sam1,TR2asam1)-min0
         bw1sam<-bw.nrd(datasim)
         t1sam<-density(x=datasim,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         Nmin<-minsize
         # Nmin =4000 for default
         # estimation of parameters for male and female groups, separately, limits the parameter estimation of
         # male+female, if the sample size in both groups are enough:
         if (min(n1,n2,n3) >=Nmin)  {
            lminsam<-min(lambda1sam,lambda2sam)
            lmaxsam<-max(lambda1sam,lambda2sam)
            nallsam<-(lmaxsam-lminsam)*100+1
            estsam<-est.dtpn2(d=datasim,l0=lminsam,sl=0.01,n=nallsam,TL=TLasam,mod=mod0sam,com=com,TR1=tr1sam,TR2=tr2sam,nen=nen)
            est1sam<-est$y0
################################
            if (est1sam[1,12]==1) {     # if no proper truncation points are found the program is stopped!!
               RLR[j1]<-RLL[j1]<-0
               } else {
               tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
               RLL[j1]<-tmsam$RLL1+min0
               RLR[j1]<-tmsam$RLR1+min0
               }
###############################################
            } else {
            estsam<-est.dtpn2(d=datasim,l0=l0,sl=0.1,n=n,TL=TLasam,mod=mod0sam,com=com,c2=dif1,TR2=TR2asam,nen=nen)
            est1sam<-estsam$y0
################################
            if (est1sam[1,12]==1) {    # if no proper truncation points are found the program is stopped!!
               RLR[j1]<-RLL[j1]<-0
               } else {
               lsam<-est1sam[8]
               TR1msam<-est1sam[4]
##############################################
               estsam<-est.dtpn2(d=datasim,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLasam,mod=mod0sam,com=com,TR1=TR1msam,TR2=TR1msam,nen=nen)
               tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
               RLL[j1]<-tmsam$RLL1+min0
               RLR[j1]<-tmsam$RLR1+min0
               }
            }
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
   RLL<-RLL[RLL=!0]
   RLR<-RLR[RLR=!0]
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
   ciDLL<-quantile(RLL,int)
   ciDLR<-quantile(RLR,int)
#######################
   LRL1<-ciDLL[1]
   LRL2<-ciDLL[2]
   URL1<-ciDLR[1]
   URL2<-ciDLR[2]
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
##############################   
   }, silent = TRUE)  # end of try
   if (length(mRLR) <= nrep/2) {   
      mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
      errm2<-"error: Confidence intervals could not be calculated for male subjects"
      }   
   if (length(wRLR) <= nrep/2)  {   
      wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
      errw2<-"error: Confidence intervals could not be calculated for female subjects"
      }  
   if (length(RLR) <= nrep/2)   {   
      LRL1<-LRL2<-URL1<-URL2<-"n.d."
      erra2<-"error: Confidence intervals could not be calculated for all subjects"
      }
   if (length(mRLR) <= nrep/2 & length(wRLR) <= nrep/2 & length(RLR) <= nrep/2)   { 
      errmess<-"error: Confidence intervals could not be calculated. Set option confidence interval=FALSE"
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
      } 
   }else if(estim.a == 0 &  estim.w==1 & estim.m==1)  {
    LRL1<-LRL2<-URL1<-URL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    try({
    j1<-1;
    while (j1<=nrep)  {
         datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
         if (model=="PN" | model=="G") {
            min1<-0
            } else {
            min1<-min(datasim11)
            }
         datasim1<-datasim11-min1
         TLmsam<-round(quantile(datasim1,q10m),com)
         TR2msam<-round(min(quantile(datasim1,Q2),max.TRm),com)
         bw1sam<-bw.nrd(datasim1)
         t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn2(d=datasim1,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            mRLR[j1]<-mRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1msam<-est1sam[4]
            estsam<-est.dtpn2(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1msam,TR2=TR1msam,nen=nen)
            lambda1sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            mRLL[j1]<-tmsam$RLL1+min1
            mRLR[j1]<-tmsam$RLR1+min1
            }         
         datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
         if (model=="PN" | model=="G") {
            min2<-0
            } else {
            min2<-min(datasim22)
            }
         datasim2<-datasim22-min2
         TLmsam<-round(quantile(datasim2,q10w),com)
         TR2msam<-round(min(quantile(datasim2,Q2),max.TRw),com)
         bw1sam<-bw.nrd(datasim2)
         t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn2(d=datasim2,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            wRLR[j1]<-wRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1wsam<-est1sam[4]
##############################################                           final estimation for female subjects (accuaracy of lambda: 0.01):
            estsam<-est.dtpn2(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1wsam,TR2=TR1wsam,nen=nen)
            lambda2sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            wRLL[j1]<-tmsam$RLL1+min2
            wRLR[j1]<-tmsam$RLR1+min2
###############################################         
            }
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
############################## 
   }, silent = TRUE)  # end of try
   if (length(mRLR) <= nrep/2)  {   
      mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
      errm2<-"error: Confidence intervals could not be calculated for male subjects"
      }   
   if (length(wRLR) <= nrep/2) {   
      wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
      errw2<-"error: Confidence intervals could not be calculated for female subjects"
      }  
   if (length(wRLR) <= nrep/2 & length(RLR) <= nrep/2)  {   
      errmess<-"error: Confidence intervals could not be calculated. Set option confidence interval=FALSE"
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
      } 
   }else if (estim.w==0 & estim.m==1) {
    cat("Calculating 90%-confidence interval for male subjects (5.H.ci.male)....   \n")
    LRL1<-LRL2<-URL1<-URL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    errw2<-"Confidence interval for female subjects has not been calculated"
    try({
    j1<-1;
    while (j1<=nrep) {
         datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
         if (model=="PN" | model=="G") {
            min1<-0
            } else {
            min1<-min(datasim11)
            }
         datasim1<-datasim11-min1
         TLmsam<-round(quantile(datasim1,q10m),com)
         TR2msam<-round(min(quantile(datasim1,Q2),max.TRm),com)
         bw1sam<-bw.nrd(datasim1)
         t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn2(d=datasim1,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            mRLR[j1]<-mRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1msam<-est1sam[4]
            estsam<-est.dtpn2(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1msam,TR2=TR1msam,nen=nen)
            lambda1sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            mRLL[j1]<-tmsam$RLL1+min1
            mRLR[j1]<-tmsam$RLR1+min1
            }         
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
##############################   
   }, silent = TRUE)  # end of try
   if (length(mRLR) <= nrep/2)
   {   
   mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."  
   errm2<-"error: Confidence intervals could not be calculated for male subjects" 
   } 
   }else if(estim.w==1 & estim.m==0)  {
    cat("Calculating 90%-confidence interval for female subjects only (5.H.ci.female)....   \n")
    LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    errm2<-"Confidence interval for male subjects has not been calculated"
    try({
    j1<-1;
    while (j1<=nrep)  {
         datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
         if (model=="PN" | model=="G") {
            min2<-0
            } else {
            min2<-min(datasim22)
            }
         datasim2<-datasim22-min2
         TLmsam<-round(quantile(datasim2,q10w),com)
         TR2msam<-round(min(quantile(datasim2,Q2),max.TRw),com)
         bw1sam<-bw.nrd(datasim2)
         t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn2(d=datasim2,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            wRLR[j1]<-wRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1wsam<-est1sam[4]
##############################################                           final estimation for female subjects (accuaracy of lambda: 0.01):
            estsam<-est.dtpn2(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1wsam,TR2=TR1wsam,nen=nen)
            lambda2sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            wRLL[j1]<-tmsam$RLL1+min2
            wRLR[j1]<-tmsam$RLR1+min2
###############################################         
            }    
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
###############################################
##############################   
   }, silent = TRUE)  # end of try
   if (length(wRLR) <= nrep/2)  {   
      wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d." 
      errw2<-"error: Confidence intervals could not be calculated for female subjects"
      }
   }else  {      # if no estimation for male and female subjects are available
    LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    errm2<-"Confidence interval for male subjects has not been calculated"
    errw2<-"Confidence interval for female subjects has not been calculated"
   }
   } else {  # if CI = FALSE
   cat("no confidence intervals (5.H.CI) ....\n")
   # n.d. (not done) instead of content
   LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
   }
########################################################################
##                                                                    ##
## 5.L   if pathological values are expected to be only low values    ##
##                                                                    ##
########################################################################

   } else if (pathol=="L") {         # if pathological values are expected to be low values
   cat("pathological = low (5.L.)....\n")
   try({
######################
   # for men first
   cat("Estimation of RL for male subjects (5.L.male)....  \n")
   TRm<-round(quantile(dmbm,Q2),com)
   TL1m<-round(quantile(dmbm,Q1),com)
   est<-est.dtpn1(d=dmbm,l0=l0,sl=0.1,n=n,TR=TRm,mod=modm,com=com,c2=dif1,TL1=TL1m,nen=nen)
   est1<-est$y0
#########################
   qstep<-0.01
   q10<-Q1
   while (est1[1,12]==1 && qstep <= q10) {
         q10<-round(q10-qstep,2)
         TL1m<-round(quantile(dmbm,q10),com)
         est<-est.dtpn1(d=dmbm,l0=l0,sl=0.1,n=n,TR=TRm,mod=modm,com=com,c2=dif1,TL1=TL1m,nen=nen)
         est1<-est$y0
         }
   if (est1[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
      estim.m<-p1<-mu1<-sig1<-lam1<-LR1<-UR1<-q10m<-TL1m<-TRm<-0
      bild4<-paste(result_file,"est_male",sep="")
      bild4.1<-paste(result_file1,"/","est_male.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild4,width=7,height=5)
      plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
      text(6,2,"No estimation for male subjects",cex=2,col="red")
      abline(0,0)
      close_plot(graph_format=graph_format,file=bild4)
      close_plot(graph_format=graph_format,file=bild4.1)
      } else {
      estim.m<-1
      l<-est1[8]
      TL1m<-est1[3]
      est<-est.dtpn1(d=dmbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TR=TRm,mod=modm,com=com,TL1=TL1m,TL2=TL1m,nen=nen)
      q10m<-q10
      lambda1<-est$y0[8]
      tm<-RLs(est=est,com=com) # calculates RLs
      estm<-est
      p1<-estm$y0[1,5]
      mu1<-estm$y0[1,6]
      sig1<-estm$y0[1,7]
      lam1<-estm$y0[1,8]
      TL1m<-estm$y0[1,3]
      LR1<-tm$RLL1+min1
      UR1<-tm$RLR1+min1
      bild4<-paste(result_file,"est_male.",graph_format,sep="")
      bild4.1<-paste(result_file1,"/","est_male.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild4,width=7,height=5)
      zm<-gr.est0(data=dmbm,est=estm,x02=x2,x01=x1,step0=stepm,bw=bwm,com=com,labx=paste(testvalue," ",testunit),low=TL1m,high=TRm,main="male",lam2=min1)
      close_plot(graph_format=graph_format,file=bild4)
      close_plot(graph_format=graph_format,file=bild4.1)
      }
    }, silent = TRUE)  # end of try
###########################
##################################
if (estim.m==0) {    
  p1<-mu1<-sig1<-lam1<-LR1<-UR1<-NA       
  errm<-"error: distribution of non-path. values for male subjects could not be separated from the whole data. Try option path=H or path=B"
  }
if (estim.m!=0 & p.U==TRUE) {
  est.pU1<-pU(x=LR1,RL1=LR1,RL2=UR1,com=com+1)
  mpU.LRL1<-est.pU1[[1]]
  mpU.LRL2<-est.pU1[[2]]
  rm(est.pU1)
  est.pU2<-pU(x=UR1,RL1=LR1,RL2=UR1,com=com+1)
  mpU.URL1<-est.pU2[[1]]
  mpU.URL2<-est.pU2[[2]]
  rm(est.pU2)
  } else {        # if  p.U==FALSE   no calculation n.d. = not done 
  mpU.LRL1<-mpU.LRL2<-mpU.URL1<-mpU.URL2<-"n.d."
  }
##################################
######    now for women:
   cat("Estimation of RL for female subjects (5.L.female)....  \n")
   try({
   TRw<-round(quantile(dwbm,Q2),com)
   TL1w<-round(quantile(dwbm,Q1),com)
   est<-est.dtpn1(d=dwbm,l0=l0,sl=0.1,n=n,TR=TRw,mod=modw,com=com,c2=dif1,TL1=TL1w,nen=nen)
   est1<-est$y0
###########################
   qstep<-0.01
   q10<-Q1
   while (est1[1,12]==1 && qstep <=q10) {
         q10<-round(q10-qstep,2)
         TL1w<-round(quantile(dwbm,q10),com)
         est<-est.dtpn1(d=dwbm,l0=l0,sl=0.1,n=n,TR=TRw,mod=modw,com=com,c2=dif1,TL1=TL1w,nen=nen)
         est1<-est$y0
         }
##########################
   if (est1[1,12]==1) { # if no proper truncation points are found the program is stopped!!
      estim.w<-p2<-mu2<-sig2<-lam2<-LR2<-UR2<-q10w<-TL1w<-TRw<-0
      bild5<-paste(result_file,"est_female",sep="")
      bild5.1<-paste(result_file1,"/","est_female.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild5,width=7,height=5)
      plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
      text(6,2,"No estimation for female subjects",cex=2,col="red")
      abline(0,0)
      close_plot(graph_format=graph_format,file=bild5)
      close_plot(graph_format=graph_format,file=bild5.1)
      } else {
      estim.w<-1
      l<-est1[8]
      TL1w<-est1[3]
      est<-est.dtpn1(d=dwbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TR=TRw,mod=modw,com=com,TL1=TL1w,TL2=TL1w,nen=nen)
      lambda2<-est$y0[8]
      q10w<-q10
      tw<-RLs(est=est,com=com) # calculates RLs
      estw<-est
      p2<-estw$y0[1,5]
      mu2<-estw$y0[1,6]
      sig2<-estw$y0[1,7]
      lam2<-estw$y0[1,8]
      TL1w<-estw$y0[1,3]
      LR2<-tw$RLL1+min2
      UR2<-tw$RLR1+min2
      bild5<-paste(result_file,"est_female.",graph_format,sep="")
      bild5.1<-paste(result_file1,"/","est_female.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild5,width=7,height=5)
      zw<-gr.est0(data=dwbm,est=estw,x02=x2,x01=x1,step0=stepw,bw=bww,com=com,labx=paste(testvalue," ",testunit),low=TL1w,high=TRw,main="female",lam2=min2)
      close_plot(graph_format=graph_format,file=bild5)
      close_plot(graph_format=graph_format,file=bild5.1)
      }
    }, silent = TRUE)  # end of try
#############################
if (estim.w==0){ 
  p2<-mu2<-sig2<-lam2<-LR2<-UR2<-NA            
  errw<-"error: distribution of non-path. values for female subjects could not be separated from the whole data. Try option path=H or path=B"
  }
if (estim.w!=0 & p.U==TRUE) {
  est.pU1<-pU(x=LR2,RL1=LR2,RL2=UR2,com=com+1)
  wpU.LRL1<-est.pU1[[1]]
  wpU.LRL2<-est.pU1[[2]]
  rm(est.pU1)
  est.pU2<-pU(x=UR2,RL1=LR2,RL2=UR2,com=com+1)
  wpU.URL1<-est.pU2[[1]]
  wpU.URL2<-est.pU2[[2]]
  rm(est.pU2)
  } else {        # if  p.U==FALSE   no calculation n.d. = not done 
  wpU.LRL1<-wpU.LRL2<-wpU.URL1<-wpU.URL2<-"n.d."
  }
###############################
##################################
######    now for men+women:
   cat("Estimation of RL for all subjects (5.L.all)....  \n")
   try({
   TRa<-round(quantile(dbm,Q2),com)
   TL1a<-round(quantile(dbm,Q1),com)
   tl1<-max(min(TL1m,TL1w),TL1a)
   tl2<-max(TL1m,TL1w,TL1a)
   Nmin<-minsize
          # Nmin =4000 for default
          # estimation of parameters for male and female groups, separately, limits the parameter estimation of
          # male+female, if the sample size in both groups are enough:
   if (estim.w != 0 & estim.m != 0 & min(n1,n2,n3) >=Nmin) {
      lmin<-min(lambda1,lambda2)
      lmax<-max(lambda1,lambda2)
      nall<-(lmax-lmin)*100+1
      est<-est.dtpn1(d=dbm,l0=lmin,sl=0.01,n=nall,TR=TRa,mod=mod,com=com,TL1=tl1,TL2=tl2,nen=nen)
      est1<-est$y0
###########################
      qstep<-0.01
      q10<-Q1
      while (est1[1,12]==1 && qstep <=q10) {
            q10<-round(q10-qstep,2)
            TL1a<-round(quantile(dbm,q10),com)
            est<-est.dtpn1(d=dbm,l0=lmin,sl=0.01,n=nall,TR=TRa,mod=mod,com=com,TL1=tl1,TL2=tl2,nen=nen)
            est1<-est$y0
            }
##########################
      if (est1[1,12]==1) { # if no proper truncation points are found the program is stopped!!
         estim.a<-0
         bild6<-paste(result_file,"est_all",sep="")
         bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")
         open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
         plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
         text(6,2,"No estimation for all subjects",cex=2,col="red")
         abline(0,0)
         close_plot(graph_format=graph_format,file=bild6)
         close_plot(graph_format=graph_format,file=bild6.1)
         } else {
         estim.a<-1
         TL1a<-est1[1,3]
         t<-RLs(est=est,com=com) # calculates RLs
         LR3<-t$RLL1+min3
         UR3<-t$RLR1+min3
         q10a<-q10
         bild6<-paste(result_file,"est_all.",graph_format,sep="")
         bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")         
         open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
         za<-gr.est0(data=dbm,est=est,x02=x2,x01=x1,step0=stepa,bw=bwa,com=com,labx=paste(testvalue," ",testunit),low=TL1a,high=TRa,main="all",lam2=min3)
         close_plot(graph_format=graph_format,file=bild6)
         close_plot(graph_format=graph_format,file=bild6.1)
         }
###########################
      } else {
      TRa<-round(quantile(dbm,Q2),com)
      TL1a<-round(quantile(dbm,Q1),com)
      est<-est.dtpn1(d=dbm,l0=l0,sl=0.1,n=n,TR=TRa,mod=mod,com=com,c2=dif1,TL1=TL1a,nen=nen)
      est1<-est$y0
      qstep<-0.01
      q10<-Q1
      while (est1[1,12]==1 && qstep <=q10) {
            q10<-round(q10-qstep,2)
            TL1a<-round(quantile(dbm,q10),com)
            est<-est.dtpn1(d=dbm,l0=l0,sl=0.1,n=n,TR=TRa,mod=mod,com=com,c2=dif1,TL1=TL1a,nen=nen)
            est1<-est$y0
            }
      if (est1[1,12]==1) { # if no proper truncation points are found the program is stopped!!
         estim.a<-0
         bild6<-paste(result_file,"est_all.",graph_format,sep="")
         bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")
         open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
         plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
         text(6,2,"No estimation for all subjects",cex=2,col="red")
         abline(0,0)
         close_plot(graph_format=graph_format,file=bild6)
         close_plot(graph_format=graph_format,file=bild6.1)
         } else {
         estim.a<-1
         l<-est1[8]
         TL1a<-est1[3]
         est<-est.dtpn1(d=dbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TR=TRa,mod=mod,com=com,TL1=TL1a,TL2=TL1a,nen=nen)
         q10a<-q10
         t<-RLs(est=est,com=com) # calculates RLs
         LR3<-t$RLL1+min3
         UR3<-t$RLR1+min3
##################################
         bild6<-paste(result_file,"est_all.",graph_format,sep="")
         bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")
         open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
         za<-gr.est0(data=dbm,est=est,x02=x2,x01=x1,step0=stepa,bw=bwa,com=com,labx=paste(testvalue," ",testunit),low=TL1a,high=TRa,main="all",lam2=min3)
         close_plot(graph_format=graph_format,file=bild6)
         close_plot(graph_format=graph_format,file=bild6.1)
         }
      }
##################################
      if (estim.a==0) {
          p3<-mu3<-sig3<-lam3<-LR3<-UR3<-q10a<-TL1a<-TRa<-0
          } else {
          p3<-est$y0[1,5]
          mu3<-est$y0[1,6]
          sig3<-est$y0[1,7]
          lam3<-est$y0[1,8]
          }
          }, silent = TRUE)  # end of try
####################################
if (estim.a==0){ 
p3<-mu3<-sig3<-lam3<-LR3<-UR3<-NA            
erra<-"error: distribution of non-path. values for all subjects could not be separated from the whole data"
}
if (estim.a!=0 & p.U==TRUE)
     {
     est.pU1<-pU(x=LR3,RL1=LR3,RL2=UR3,com=com+1)
     pU.LRL1<-est.pU1[[1]]
     pU.LRL2<-est.pU1[[2]]
     rm(est.pU1)
     est.pU2<-pU(x=UR3,RL1=LR3,RL2=UR3,com=com+1)
     pU.URL1<-est.pU2[[1]]
     pU.URL2<-est.pU2[[2]]
     rm(est.pU2)
}
else {        # if  p.U==FALSE   no calculation n.d. = not done 
pU.LRL1<-pU.LRL2<-pU.URL1<-pU.URL2<-"n.d."
}
####################################
if (estim.a==0 & estim.w==0 & estim.m==0){            
errmess<-"error: distribution of non-path. values could not be separated from the whole data. Set option pathological values =  H (High) or = B (both).
          Read prog_log.txt data for more informations."
sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
end.time <- date()
cat("Program start:", start.time,"\n")
cat("program end:  ", end.time,"\n")
cat("================================================================\n\n")
cat("estimation of RLs:","\n")
cat("male subjects:", errm , "\n")
cat("female subjects:", errw , "\n")
cat("all subjects:", erra , "\n\n")
sink()
##################################
### copy in flag file and subfolder:
write.table(d, file = flag_file,quote=F,sep=";",col.names=TRUE)
write.csv(d, file = savename2,quote=F)
Result2<-paste(result_file1,"/","result2.csv",sep="")
write.csv(d, file = Result2,quote=F)
write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n\n")
write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n\n")
quit(save = "no", status = 0, runLast = FALSE)
   }
###########################################################################
##                                                                       ##
## 5.L.stat testing the null hypothesis for the estimated distributions  ##
##        pathol==L                                                      ##
##                                                                       ##
###########################################################################
if (stat_test=="TRUE"){
   cat("testing the null hypothesis (5.L.stat.)....\n")
#
####################
   if (estim.m==0 | nmc <= 0){ 
   KSemp1<-KSth1<-pvalue1<- "n.d." 
   errm1<-"p-value will not be calculated for male subjects" 
   cat("p-value will not be calculated for male subjects  \n")
   }else{
try({
      test<-KS.rtpn.test(data=dmbm,est=estm,n1=nmc,alpha1=alpha1,sl=0.01,
      m1=101,nen=nen,epsilon=1E-4,I=100,mod=modm,com=com)
      }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
                             KSemp1<-KSth1<-pvalue1<- "n.d."          
                             errm1<-"error: p-value could not be calculated for male subjects."
                             cat("p-value could not be calculated for male subjects  \n")
                             }else{
                             KSemp1<-round(test$KolmEmp,4)
                             KSth1<-round(test$KDcr5,4)
                             pvalue1<-test$px
                             rm(test)
                             } 
     }
################################   for female subjects
   if (estim.w==0 | nmc <= 0) {
   KSemp2<-KSth2<-pvalue2<- "n.d." 
   errw1<-"p-value will not be calculated for female subjects" 
   cat("p-value will not be calculated for female subjects  \n")
   }else{
   try({
      test<-KS.rtpn.test(data=dwbm,est=estw,n1=nmc,alpha1=alpha1,sl=0.01,
      m1=101,nen=nen,epsilon=1E-4,I=100,mod=modw,com=com)
      }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
                             KSemp2<-KSth2<-pvalue2<- "n.d."          
                             errw1<-"error: p-value could not be calculated for female subjects."
                             cat("p-value could not be calculated for female subjects  \n")
                             }else{
                             KSemp2<-round(test$KolmEmp,4)
                             KSth2<-round(test$KDcr5,4)
                             pvalue2<-test$px
                             rm(test)
                             } 
      }
###############################  for all (male and female)
   if (estim.a==0 | nmc <= 0){ 
   KSemp3<-KSth3<-pvalue3<- "n.d." 
   erra1<-"p-value will not be calculated for all subjects" 
   cat("p-value will not be calculated for all subjects  \n")
   }else{
   try({
      test<-KS.rtpn.test(data=dbm,est=est,n1=nmc,alpha1=alpha1,sl=0.01,
      m1=101,nen=nen,epsilon=1E-4,I=100,mod=mod,com=com)
       }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
         KSemp3<-KSth3<-pvalue3<- "n.d."          
         erra1<-"error: p-value could not be calculated for all subjects."
         cat("p-value could not be calculated for all subjects  \n")
         }else{
         KSemp3<-round(test$KolmEmp,4)
         KSth3<-round(test$KDcr5,4)
         pvalue3<-test$px
         rm(test)
         } 
      }  
   } else {
   cat("without testing the null hypothesis (5.L.stat.)....\n")
   # n.d. (not done) instead of content
   KSemp1<-KSemp2<-KSemp3<-KSth1<-KSth2<-KSth3<-pvalue1<-pvalue2<-pvalue3<-"n.d."
   }  
######################################################
##                                                  ##
##  5.L.CI   calculating 95% confidence intervals   ##
##           pathol==L                              ##
##                                                  ##
######################################################

if (ci=="TRUE" & nrep > 0) {
    cat("calculating confidence intervals (5.L.CI.)....\n")
    mRLR<-mRLL<-wRLR<-wRLL<-RLR<-RLL<-c(rep(0,nrep))
    if (estim.a==1 & estim.w==1 & estim.m==1)
    {  # if estimations for male, female and all subjects were successfully.   
    try({
    j1<-1;
    while (j1<=nrep) {
          datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
          if (model=="PN" | model=="G") {
             min1<-0
             } else {
             min1<-min(datasim11)
             }
          datasim1<-datasim11-min1
          TLmsam<-round(quantile(datasim1,q10m),com)
          TR2msam<-round(quantile(datasim1,Q2),com)
          bw1sam<-bw.nrd(datasim1)
          t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
          k1sam<-t1sam$y
          u1sam<-t1sam$x
          a.maxsam<-which.max(k1sam)
          mod0sam<-u1sam[a.maxsam]
          estsam<-est.dtpn1(d=datasim1,l0=l0,sl=0.1,n=n,TL1=TLmsam,mod=mod0sam,com=com,c2=dif1,TR=TR2msam,nen=nen)
          est1sam<-estsam$y0
################################
          if (est1sam[1,12]==1) { # if no proper truncation points are found the program is stopped!!
             mRLR[j1]<-mRLL[j1]<-0
             } else {
             lsam<-est1sam[8]
             TLmsam<-est1sam[3]
####################################################
             estsam<-est.dtpn1(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL1=TLmsam,TL2=TLmsam,mod=mod0sam,com=com,TR=TR2msam,nen=nen)
             lambda1sam<-estsam$y0[8]
             tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
             mRLL[j1]<-tmsam$RLL1+min1
             mRLR[j1]<-tmsam$RLR1+min1
###############################################
             }
          datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
          if (model=="PN" | model=="G") {
             min2<-0
             } else {
             min2<-min(datasim22)
             }
          datasim2<-datasim22-min2
          TLmsam<-round(quantile(datasim2,q10w),com)
          TR2msam<-round(quantile(datasim2,Q2),com)
          bw1sam<-bw.nrd(datasim2)
          t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
          k1sam<-t1sam$y
          u1sam<-t1sam$x
          a.maxsam<-which.max(k1sam)
          mod0sam<-u1sam[a.maxsam]
          estsam<-est.dtpn1(d=datasim2,l0=l0,sl=0.1,n=n,TL1=TLmsam,mod=mod0sam,com=com,c2=dif1,TR=TR2msam,nen=nen)
          est1sam<-estsam$y0
#########################
################################
          if (est1sam[1,12]==1) { # if no proper truncation points are found the program is stopped!!
             wRLR[j1]<-wRLL[j1]<-0
             } else {
             lsam<-est1sam[8]
             TLwsam<-est1sam[3]
##############################################
             estsam<-est.dtpn1(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL1=TLwsam,TL2=TLwsam,mod=mod0sam,com=com,TR=TR2msam,nen=nen)
             lambda2sam<-estsam$y0[8]
             tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
             wRLL[j1]<-tmsam$RLL1+min2
             wRLR[j1]<-tmsam$RLR1+min2
###############################################
             }
          min0<-min(min1,min2)
          datasim<-c(datasim11,datasim22)
          datasim<-datasim-min0
          TLasam<-round(quantile(datasim,q10a),com)
          TR2asam<-round(quantile(datasim,Q2),com)
          TLmsam1<-TLmsam+min1  # not transformed optimala truncation point for male
          TLwsam1<-TLwsam+min2  # not transformed optimala truncation point for female
          TLasam1<-TLasam+min0  # the first limit for trunction point for male+females
          tl1sam<-min(TLmsam1,TLwsam1)-min0
          tl2sam<-max(TLmsam1,TLwsam1)-min0
          bw1sam<-bw.nrd(datasim)
          t1sam<-density(x=datasim,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
          k1sam<-t1sam$y
          u1sam<-t1sam$x
          a.maxsam<-which.max(k1sam)
          mod0sam<-u1sam[a.maxsam]
          Nmin<-minsize
    # Nmin =4000 for default
    # estimation of parameters for male and female groups, separately, limits the parameter estimation of
    # male+female, if the sample size in both groups are enough:
          if (min(n1,n2,n3) >=Nmin) {
             lminsam<-min(lambda1sam,lambda2sam)
             lmaxsam<-max(lambda1sam,lambda2sam)
             nallsam<-(lmaxsam-lminsam)*100+1
             estsam<-est.dtpn1(d=datasim,l0=lminsam,sl=0.01,n=nallsam,TL1=tl1sam,TL2=tl2sam,mod=mod0sam,com=com,TR=TR2asam,nen=nen)
             est1sam<-est$y0
######################################################################
             if (est1sam[1,12]==1) { # if no proper truncation points are found the program is stopped!!
                RLR[j1]<-RLL[j1]<-0
                } else {
                tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
                RLL[j1]<-tmsam$RLL1+min0
                RLR[j1]<-tmsam$RLR1+min0
                }
######################################################################
             } else {
             estsam<-est.dtpn1(d=datasim,l0=l0,sl=0.1,n=n,TL1=TLasam,mod=mod0sam,com=com,c2=dif1,TR=TR2asam,nen=nen)
             est1sam<-estsam$y0
#####################################################################
             if (est1sam[1,12]==1) { # if no proper truncation points are found the program is stopped!!
                RLR[j1]<-RLL[j1]<-0
                } else {
                lsam<-est1sam[8]
                TLasam<-est1sam[3]
                estsam<-est.dtpn1(d=datasim,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL1=TLasam,mod=mod0sam,com=com,TR=TR2asam,nen=nen)
                tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
                RLL[j1]<-tmsam$RLL1+min0
                RLR[j1]<-tmsam$RLR1+min0
                }
             }
####################################################################
####################################################################
             j1<-j1+1
          }
##########################
##########################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
   RLL<-RLL[RLL=!0]
   RLR<-RLR[RLR=!0]
########################
#ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
   ciDLL<-quantile(RLL,int)
   ciDLR<-quantile(RLR,int)
#######################
   LRL1<-ciDLL[1]
   LRL2<-ciDLL[2]
   URL1<-ciDLR[1]
   URL2<-ciDLR[2]
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
##############################
}, silent = TRUE)  # end of try
   if (length(mRLR) <= nrep/2)
   {   
   mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
   errm2<-"error: Confidence intervals could not be calculated for male subjects"
   cat("Confidence interval could not be calculated for male subjects  \n")
   }   
   if (length(wRLR) <= nrep/2)
   {   
   wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
   errw2<-"error: Confidence intervals could not be calculated for male subjects"
   cat("Confidence interval could not be calculated for male subjects  \n")
   }  
   if (length(RLR) <= nrep/2)  {   
   LRL1<-LRL2<-URL1<-URL2<-"n.d."
   erra2<-"error: Confidence intervals could not be calculated for all subjects"
   cat("Confidence intervals could not be calculated for alle subjects \n")
   }
   if (length(mRLR) <= nrep/2 & length(wRLR) <= nrep/2 & length(RLR) <= nrep/2) {  
      errmess<-"error: Confidence intervals could not be calculate. Set option confidence interval=FALSE"
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
      #quit(save = "no", status = 0, runLast = FALSE)
      } 
   }else if (estim.a == 0 &  estim.w==1 & estim.m==1) {
    LRL1<-LRL2<-URL1<-URL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    try({
    j1<-1;
    while (j1<=nrep) {
#########################
          datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
          if (model=="PN" | model=="G") {
             min1<-0
             } else {
             min1<-min(datasim11)
             }
          datasim1<-datasim11-min1
          TLmsam<-round(quantile(datasim1,q10m),com)
          TR2msam<-round(quantile(datasim1,Q2),com)
          bw1sam<-bw.nrd(datasim1)
          t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
          k1sam<-t1sam$y
          u1sam<-t1sam$x
          a.maxsam<-which.max(k1sam)
          mod0sam<-u1sam[a.maxsam]
          estsam<-est.dtpn1(d=datasim1,l0=l0,sl=0.1,n=n,TL1=TLmsam,mod=mod0sam,com=com,c2=dif1,TR=TR2msam,nen=nen)
          est1sam<-estsam$y0
################################
          if (est1sam[1,12]==1) { # if no proper truncation points are found the program is stopped!!
             mRLR[j1]<-mRLL[j1]<-0
             } else {
             lsam<-est1sam[8]
             TLmsam<-est1sam[3]
####################################################
             estsam<-est.dtpn1(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL1=TLmsam,TL2=TLmsam,mod=mod0sam,com=com,TR=TR2msam,nen=nen)
             lambda1sam<-estsam$y0[8]
             tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
             mRLL[j1]<-tmsam$RLL1+min1
             mRLR[j1]<-tmsam$RLR1+min1
###############################################
             }
          datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
          if (model=="PN" | model=="G") {
             min2<-0
             } else {
             min2<-min(datasim22)
             }
          datasim2<-datasim22-min2
          TLmsam<-round(quantile(datasim2,q10w),com)
          TR2msam<-round(quantile(datasim2,Q2),com)
          bw1sam<-bw.nrd(datasim2)
          t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
          k1sam<-t1sam$y
          u1sam<-t1sam$x
          a.maxsam<-which.max(k1sam)
          mod0sam<-u1sam[a.maxsam]
          estsam<-est.dtpn1(d=datasim2,l0=l0,sl=0.1,n=n,TL1=TLmsam,mod=mod0sam,com=com,c2=dif1,TR=TR2msam,nen=nen)
          est1sam<-estsam$y0
#########################
################################
          if (est1sam[1,12]==1) { # if no proper truncation points are found the program is stopped!!
             wRLR[j1]<-wRLL[j1]<-0
             } else {
             lsam<-est1sam[8]
             TLwsam<-est1sam[3]
##############################################
             estsam<-est.dtpn1(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL1=TLwsam,TL2=TLwsam,mod=mod0sam,com=com,TR=TR2msam,nen=nen)
             lambda2sam<-estsam$y0[8]
             tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
             wRLL[j1]<-tmsam$RLL1+min2
             wRLR[j1]<-tmsam$RLR1+min2
###############################################
             }
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
##############################   
   }, silent = TRUE)  # end of try
   if (length(mRLR) <=nrep/2)  {   
      mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
      errm2<-"Confidence interval for male subjects has not been calculated"
      cat("Confidence interval for male subjects has not been calculated  \n")
      }   
   if (length(wRLR) <=nrep/2) {   
      wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
      errw2<-"Confidence interval for female subjects has not been calculated"
      cat("Confidence interval for female subjects has not been calculated  \n")
      }  
   if (length(wRLR) <= nrep/2 & length(RLR) <= nrep/2)  {  
      errmess<-"error: Confidence intervals could not be calculate. Set option confidence interval=FALSE"
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
      #quit(save = "no", status = 0, runLast = FALSE)
      } 
   }else if (estim.w==0 & estim.m==1) {
    LRL1<-LRL2<-URL1<-URL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    errw2<-"Confidence interval for female subjects has not been calculated"
    cat("Confidence interval for all subjects has not been calculated  \n")
    cat("Confidence interval for female subjects has not been calculated  \n")
    try({
    j1<-1;
    while (j1<=nrep) {
#########################
          datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
          if (model=="PN" | model=="G") {
             min1<-0
             } else {
             min1<-min(datasim11)
             }
          datasim1<-datasim11-min1
          TLmsam<-round(quantile(datasim1,q10m),com)
          TR2msam<-round(quantile(datasim1,Q2),com)
          bw1sam<-bw.nrd(datasim1)
          t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
          k1sam<-t1sam$y
          u1sam<-t1sam$x
          a.maxsam<-which.max(k1sam)
          mod0sam<-u1sam[a.maxsam]
          estsam<-est.dtpn1(d=datasim1,l0=l0,sl=0.1,n=n,TL1=TLmsam,mod=mod0sam,com=com,c2=dif1,TR=TR2msam,nen=nen)
          est1sam<-estsam$y0
################################
          if (est1sam[1,12]==1) { # if no proper truncation points are found the program is stopped!!
             mRLR[j1]<-mRLL[j1]<-0
             } else {
             lsam<-est1sam[8]
             TLmsam<-est1sam[3]
####################################################
             estsam<-est.dtpn1(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL1=TLmsam,TL2=TLmsam,mod=mod0sam,com=com,TR=TR2msam,nen=nen)
             lambda1sam<-estsam$y0[8]
             tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
             mRLL[j1]<-tmsam$RLL1+min1
             mRLR[j1]<-tmsam$RLR1+min1
###############################################
             }
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
##############################   
   }, silent = TRUE)  # end of try
   if (length(mRLR) <= nrep/2)
   {   
   mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."   
   errmess<-"error: Confidence intervals could not be calculate. Set option confidence interval=FALSE"
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
   #quit(save = "no", status = 0, runLast = FALSE)
   } 
   }else if(estim.w==1 & estim.m==0)
   {
    LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    errm2<-"Confidence interval for male subjects has not been calculated"  
    cat("Confidence interval for all subjects has not been calculated  \n")
    cat("Confidence interval for male subjects has not been calculated  \n")
    try({
    j1<-1;
    while (j1<=nrep) {
       datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
       if (model=="PN" | model=="G") {
          min2<-0
          } else {
          min2<-min(datasim22)
          }
       datasim2<-datasim22-min2
       TLmsam<-round(quantile(datasim2,q10w),com)
       TR2msam<-round(quantile(datasim2,Q2),com)
       bw1sam<-bw.nrd(datasim2)
       t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
       k1sam<-t1sam$y
       u1sam<-t1sam$x
       a.maxsam<-which.max(k1sam)
       mod0sam<-u1sam[a.maxsam]
       estsam<-est.dtpn1(d=datasim2,l0=l0,sl=0.1,n=n,TL1=TLmsam,mod=mod0sam,com=com,c2=dif1,TR=TR2msam,nen=nen)
       est1sam<-estsam$y0
#########################
################################
       if (est1sam[1,12]==1) { # if no proper truncation points are found the program is stopped!!
          wRLR[j1]<-wRLL[j1]<-0
          } else {
          lsam<-est1sam[8]
          TLwsam<-est1sam[3]
          estsam<-est.dtpn1(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL1=TLwsam,TL2=TLwsam,mod=mod0sam,com=com,TR=TR2msam,nen=nen)
          lambda2sam<-estsam$y0[8]
          tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
          wRLL[j1]<-tmsam$RLL1+min2
          wRLR[j1]<-tmsam$RLR1+min2
          }
###############################################
       j1<-j1+1
       }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
###############################################
##############################   
   }, silent = TRUE)  # end of try
   if (length(wRLR) <= nrep/2){   
      wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."   
      errmess<-"error: Confidence intervals could not be calculate. Set option confidence interval=FALSE"
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
      #quit(save = "no", status = 0, runLast = FALSE)
      }
   }else {      # if no estimation for male and female subjects are available
    LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    errm2<-"Confidence interval for male subjects has not been calculated"
    errw2<-"Confidence interval for female subjects has not been calculated"
   }
   } else {  # if CI = FALSE
   cat("no confidence intervals (5.H.CI) ....\n")
   # n.d. (not done) instead of content
   LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
   }
#######################################
###########################################################################
##                                                                       ##
## 5.B   if pathological values are expected to be low and high values   ##
##                                                                       ##
###########################################################################

} else if (pathol=="B"){       # if pathological values are expected to be low and high values
######################
   cat("pathological = low and high (5.B.) ....\n")
   try({
   #######################################################################
   #### First estimation for male subjects (accuaracy of lambda: 0.1):
   #######################################################################
   cat("Estimation of RL for male subjects (5.B.male)....  \n")
   TLm<-round(quantile(dmbm,Q1),com)
   if(max.TRm > modm1){
      TR2m<-round(min(quantile(dmbm,Q2),max.TRm),com)
      }else{
      TR2m<-round(quantile(dmbm,Q2),com) 
      } 
   est<-est.dtpn0(d=dmbm,l0=l0,sl=0.1,n=n,TL=TLm,mod=modm,com=com,c2=dif1,TR2=TR2m,nen=nen)
   est1<-est$y0
#########################
   qstep<-0.01
   q10<-Q1
   while (est1[1,12]==1 && qstep <=q10) { # if the truncated part is too narrow, it will be boarder.
      q10<-round(q10-qstep,2)
      TLm<-round(quantile(dmbm,q10),com)
      est<-est.dtpn0(d=dmbm,l0=l0,sl=0.1,n=n,TL=TLm,mod=modm,com=com,c2=dif1,TR2=TR2m,nen=nen)
      est1<-est$y0
      }
################################
   if (est1[1,12]==1) {    # if no proper truncation points are found the program is stopped!!
      estim.m<-p1<-mu1<-sig1<-lam1<-LR1<-UR1<-q10m<-TLm<-TR1m<-0
      bild4<-paste(result_file,"est_male.",graph_format,sep="")
      bild4.1<-paste(result_file1,"est_male.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild4,width=7,height=5)
      plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
      text(6,2,"No estimation for male subjects",cex=2,col="red")
      abline(0,0)
      close_plot(graph_format=graph_format,file=bild4)
      close_plot(graph_format=graph_format,file=bild4.1)
      } else {
      estim.m<-1
      l<-est1[8]
      TLm<-est1[3]
      TR1m<-est1[4]
#### final estimation for male subjects (accuaracy of lambda: 0.01):
      est<-est.dtpn0(d=dmbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TL=TLm,mod=modm,com=com,TR1=TR1m,TR2=TR1m,nen=nen)
      q10m<-q10
      lambda1<-est$y0[8]
#########################
      tm<-RLs(est=est,com=com)                             # calculates RLs
      estm<-est
      p1<-estm$y0[1,5]
      mu1<-estm$y0[1,6]
      sig1<-estm$y0[1,7]
      lam1<-estm$y0[1,8]
      LR1<-tm$RLL1+min1
      UR1<-tm$RLR1+min1
######################################################
######################################################
######################################################
######################################################
      # step4- graphical display of estimations
      # Description of function gr.est below:
      # display the estimated distributions for pathological and non-pathological values
      # est: estimated distribution above
      # x01 and x02: limits of  x-axis inthe figure
      # step0: estimated banwidth above
      # com:  indicates the number of decimal places (see above)
      # low: lower limit to calculate the pathological density funtion. Default=mod of the data estimated above, then
      # it is assumed that all values below the mod of data stem from non-pathological values
###################################
      bild4<-paste(result_file,"est_male.",graph_format,sep="")
      bild4.1<-paste(result_file1,"/","est_male.",graph_format,sep="")      
      open_plot(graph_format=graph_format,file=bild4,width=7,height=5)
      zm<-gr.est0(data=dmbm,est=estm,x02=x2,x01=x1,step0=stepm,bw=bwm,com=com,labx=paste(testvalue," ",testunit),low=TLm,high=TR1m,main="male",lam2=min1)
      close_plot(graph_format=graph_format,file=bild4)
      close_plot(graph_format=graph_format,file=bild4.1)
      }
      }, silent = TRUE)  # end of try
####################################
if (estim.m==0) {    
  p1<-mu1<-sig1<-lam1<-LR1<-UR1<-NA       
  errm<-"error: distribution of non-path. values for male subjects could not be separated from the whole data. Try option path=L or path=H"
  }
if (estim.m!=0 & p.U==TRUE) {
  est.pU1<-pU(x=LR1,RL1=LR1,RL2=UR1,com=com+1)
  mpU.LRL1<-est.pU1[[1]]
  mpU.LRL2<-est.pU1[[2]]
  rm(est.pU1)
  est.pU2<-pU(x=UR1,RL1=LR1,RL2=UR1,com=com+1)
  mpU.URL1<-est.pU2[[1]]
  mpU.URL2<-est.pU2[[2]]
  rm(est.pU2)
  } else {        # if  p.U==FALSE   no calculation n.d. = not done 
  mpU.LRL1<-mpU.LRL2<-mpU.URL1<-mpU.URL2<-"n.d."
  }
##################################
######    now for women:
##################################
cat("Estimation of RL for female subjects (5.B.female)....  \n")
try({
   TLw<-round(quantile(dwbm,Q1),com)
   if (max.TRw > modw1){
     TR2w<-round(min(quantile(dwbm,Q2),max.TRw),com)
     }else{
     TR2w<-round(quantile(dwbm,Q2),com) 
     } 
   est<-est.dtpn0(d=dwbm,l0=l0,sl=0.1,n=n,TL=TLw,mod=modw,com=com,c2=dif1,TR2=TR2w,nen=nen)
   est1<-est$y0
###########################
   qstep<-0.01
   q10<-Q1
   while (est1[1,12]==1 && qstep <=q10) {
         q10<-round(q10-qstep,2)
         TLw<-round(quantile(dwbm,q10),com)
         est<-est.dtpn0(d=dwbm,l0=l0,sl=0.1,n=n,TL=TLw,mod=modw,com=com,c2=dif1,TR2=TR2w,nen=nen)
         est1<-est$y0
         }
##########################
   if (est1[1,12]==1) { # if no proper truncation points are found the program is stopped!!
      estim.w<-p2<-mu2<-sig2<-lam2<-LR2<-UR2<-q10w<-TLw<-TR1w<-0
      bild5<-paste(result_file,"est_female.",graph_format,sep="")
      bild5.1<-paste(result_file1,"est_female.",graph_format,sep="")
      open_plot(graph_format=graph_format,file=bild5,width=7,height=5)
      plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
      text(6,2,"No estimation for female subjects",cex=2,col="red")
      abline(0,0)
      close_plot(graph_format=graph_format,file=bild5)
      close_plot(graph_format=graph_format,file=bild5.1)
      } else {
######################
      estim.w<-1
      l<-est1[8]
      TLw<-est1[3]
      TR1w<-est1[4]
      est<-est.dtpn0(d=dwbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TL=TLw,mod=modw,com=com,TR1=TR1w,TR2=TR1w,nen=nen)
      lambda2<-est$y0[8]
      q10w<-q10
      tw<-RLs(est=est,com=com) # calculates RLs
      estw<-est
      p2<-estw$y0[1,5]
      mu2<-estw$y0[1,6]
      sig2<-estw$y0[1,7]
      lam2<-estw$y0[1,8]
      LR2<-tw$RLL1+min2
      UR2<-tw$RLR1+min2
######################################################
######################################################
######################################################
######################################################
      bild5<-paste(result_file,"est_female.",graph_format,sep="")
      bild5.1<-paste(result_file1,"/","est_female.",graph_format,sep="")      
      open_plot(graph_format=graph_format,file=bild5,width=7,height=5)
      zw<-gr.est0(data=dwbm,est=estw,x02=x2,x01=x1,step0=stepw,bw=bww,com=com,labx=paste(testvalue," ",testunit),low=TLw,high=TR1w,main="female",lam2=min2)
      close_plot(graph_format=graph_format,file=bild5)
      close_plot(graph_format=graph_format,file=bild5.1)
      }
      }, silent = TRUE)  # end of try
####################################        
if (estim.w==0){ 
  p2<-mu2<-sig2<-lam2<-LR2<-UR2<-NA            
  errw<-"error: distribution of non-path. values for female subjects could not be separated from the whole data. Try option path=L or path=H"
  }
if (estim.w!=0 & p.U==TRUE) {
  est.pU1<-pU(x=LR2,RL1=LR2,RL2=UR2,com=com+1)
  wpU.LRL1<-est.pU1[[1]]
  wpU.LRL2<-est.pU1[[2]]
  rm(est.pU1)
  est.pU2<-pU(x=UR2,RL1=LR2,RL2=UR2,com=com+1)
  wpU.URL1<-est.pU2[[1]]
  wpU.URL2<-est.pU2[[2]]
  rm(est.pU2)
  } else {        # if  p.U==FALSE   no calculation n.d. = not done 
  wpU.LRL1<-wpU.LRL2<-wpU.URL1<-wpU.URL2<-"n.d."
  }
##################################
######    now for men+women:
##################################
cat("Estimation of RL for all subjects (5.B.all)....  \n")
try({
    Nmin<-minsize
    TLa<-round(quantile(dbm,Q1),com)
    if(max.TR > mod1){
       TR2a<-round(min(quantile(dbm,Q2),max.TR),com)
       }else{
       TR2a<-round(quantile(dbm,Q2),com) 
       } 
    if(estim.w != 0 & estim.m != 0 & min(n1,n2,n3) >=Nmin){ 
       TR1m1<-TR1m+min1  # not transformed optimala truncation point for male
       TR1w1<-TR1w+min2  # not transformed optimala truncation point for female
       TR2a1<-TR2a+min3  # the first limit for trunction point for male+females
       Trr1<-min(TR1m1,TR1w1)
       Trr2<-max(TR1m1,TR1w1)
       tr1<-min(Trr1,TR2a1)-min3
       tr2<-min(Trr2,TR2a1)-min3
       qstep<-0.01
       lmin<-min(lambda1,lambda2)
       lmax<-max(lambda1,lambda2)
       nall<-(lmax-lmin)*100+1
       est<-est.dtpn0(d=dbm,l0=lmin,sl=0.01,n=nall,TL=TLa,mod=mod,com=com,TR1=tr1,TR2=tr2,nen=nen)
       est1<-est$y0
###########################
      qstep<-0.01
      q10<-Q1
      while (est1[1,12]==1 && qstep <=q10) {
            q10<-round(q10-qstep,2)
            TLa<-round(quantile(dbm,q10),com)
            est<-est.dtpn0(d=dbm,l0=lmin,sl=0.01,n=nall,TL=TLa,mod=mod,com=com,TR1=tr1,TR2=tr2,nen=nen)
            est1<-est$y0
            }
################################
      if (est1[1,12]==1) { # if no proper truncation points are found the program is stopped!!
         estim.a<-0
         bild6<-paste(result_file,"est_all.",graph_format,sep="")
         bild6.1<-paste(result_file1,"est_all.",graph_format,sep="")
         open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
         plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
         text(6,2,"No estimation for all subjects",cex=2,col="red")
         abline(0,0)
         close_plot(graph_format=graph_format,file=bild6)
         close_plot(graph_format=graph_format,file=bild6.1)
         } else {
         estim.a<-1
##########################
         TLa<-est1[3]
         TR1a<-est1[4]
         t<-RLs(est=est,com=com) # calculates RLs
         LR3<-t$RLL1+min3
         UR3<-t$RLR1+min3
         q10a<-q10
         bild6<-paste(result_file,"est_all.",graph_format,sep="")
         bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")         
         open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
         za<-gr.est0(data=dbm,est=est,x02=x2,x01=x1,step0=stepa,bw=bwa,com=com,labx=paste(testvalue," ",testunit),low=TLa,high=TR1a,main="all",lam2=min3)
         close_plot(graph_format=graph_format,file=bild6)
         close_plot(graph_format=graph_format,file=bild6.1)
         }
      } else {
      TLa<-round(quantile(dbm,Q1),com)
      est<-est.dtpn0(d=dbm,l0=l0,sl=0.1,n=n,TL=TLa,mod=mod,com=com,c2=dif1,TR2=TR2a,nen=nen)
      est1<-est$y0
      qstep<-0.01
      q10<-Q1
      while (est1[1,12]==1 && qstep <=q10) {
            q10<-round(q10-qstep,2)
            TLa<-round(quantile(dbm,q10),com)
            TR2a<-round(min(quantile(dbm[dbm>=TLa],Q2),max.TR),com)
            est<-est.dtpn0(d=dbm,l0=l0,sl=0.1,n=n,TL=TLa,mod=mod,com=com,c2=dif1,TR2=TR2a,nen=nen)
            est1<-est$y0
            }
 ################################
      if (est1[1,12]==1) { # if no proper truncation points are found the program is stopped!!
         estim.a<-0
         bild6<-paste(result_file,"est_all.",graph_format,sep="")
         bild6.1<-paste(result_file1,"est_all.",graph_format,sep="")
         open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
         plot(1:10,1:10,main="",axes=FALSE,col="white",xlab="",ylab="")
         text(6,2,"No estimation for all subjects",cex=2,col="red")
         abline(0,0)
         close_plot(graph_format=graph_format,file=bild6)
         close_plot(graph_format=graph_format,file=bild6.1)
         } else {
         estim.a<-1
         l<-est1[8]
         TLa<-est1[3]
         TR1a<-est1[4]
         est<-est.dtpn0(d=dbm,l0=max(0,l-lstep),sl=0.01,n=nstep,TL=TLa,mod=mod,com=com,TR1=TR1a,TR2=TR1a,nen=nen)
         q10a<-q10
         t<-RLs(est=est,com=com) # calculates RLs
         LR3<-t$RLL1+min3
         UR3<-t$RLR1+min3
         bild6<-paste(result_file,"est_all.",graph_format,sep="")
         bild6.1<-paste(result_file1,"/","est_all.",graph_format,sep="")         
         open_plot(graph_format=graph_format,file=bild6,width=7,height=5)
         za<-gr.est0(data=dbm,est=est,x02=x2,x01=x1,step0=stepa,bw=bwa,com=com,labx=paste(testvalue," ",testunit),low=TLa,high=TR1a,main="all",lam2=min3)
         close_plot(graph_format=graph_format,file=bild6)
         close_plot(graph_format=graph_format,file=bild6.1)
         }
      }
      if (estim.a==0) {
         p3<-mu3<-sig3<-lam3<-LR3<-UR3<-q10a<-TLa<-TR1a<-0
         } else {
         p3<-est$y0[1,5]
         mu3<-est$y0[1,6]
         sig3<-est$y0[1,7]
         lam3<-est$y0[1,8]
         }
      }, silent = TRUE)  # end of try
####################################    
if (estim.a==0){ 
  p3<-mu3<-sig3<-lam3<-LR3<-UR3<-NA            
  erra<-"error: distribution of non-path. values for all subjects could not be separated from the whole data"
  }
if (estim.a!=0 & p.U==TRUE) {
     est.pU1<-pU(x=LR3,RL1=LR3,RL2=UR3,com=com+1)
     pU.LRL1<-est.pU1[[1]]
     pU.LRL2<-est.pU1[[2]]
     rm(est.pU1)
     est.pU2<-pU(x=UR3,RL1=LR3,RL2=UR3,com=com+1)
     pU.URL1<-est.pU2[[1]]
     pU.URL2<-est.pU2[[2]]
     rm(est.pU2)
     } else {        # if  p.U==FALSE   no calculation n.d. = not done 
     pU.LRL1<-pU.LRL2<-pU.URL1<-pU.URL2<-"n.d."
     }
#######################################
if (estim.a==0 & estim.w==0 & estim.m==0){            
errmess<-"error: distribution of non-path. values could not be separated from the whole data. Set option pathological values = L (low) or = H (High).
          Read prog_log.txt data for more informations."
sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
end.time <- date()
cat("Program start:", start.time,"\n")
cat("program end:  ", end.time,"\n")
cat("================================================================\n\n")
cat("estimation of RLs:","\n")
cat("male subjects:", errm , "\n")
cat("female subjects:", errw , "\n")
cat("all subjects:", erra , "\n\n")
sink()
##################################
### copy in flag file and subfolder:
write.table(d, file = flag_file,quote=F,sep=";",col.names=TRUE)
write.csv(d, file = savename2,quote=F)
Result2<-paste(result_file1,"/","result2.csv",sep="")
write.csv(d, file = Result2,quote=F)
write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n\n")
write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n\n")
quit(save = "no", status = 0, runLast = FALSE)
   }
###########################################################################
##                                                                       ##
## 5.B.stat testing the null hypothesis for the estimated distributions  ##
##        pathol==B                                                      ##
##                                                                       ##
###########################################################################
if (stat_test=="TRUE"){
   cat("testing the null hypothesis (5.H.stat.)....\n")
#
####################
   if (estim.m==0 | nmc <= 0){ 
   KSemp1<-KSth1<-pvalue1<- "n.d."  
   errm1<-"p-value will not be calculated for male subjects"
   cat("p-value will not be calculated for male subjects   \n")
   }else{
   try({
      test<-KS.rtpn.test(data=dmbm,est=estm,n1=nmc,alpha1=alpha1,sl=0.01,
      m1=101,nen=nen,epsilon=1E-4,I=100,mod=modm,com=com)
      }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
                             KSemp1<-KSth1<-pvalue1<- "n.d."          
                             errm1<-"error: p-value could not be calculated for male subjects."
                             cat("p-value could not be calculated for male subjects   \n")
                             }else{
                             KSemp1<-round(test$KolmEmp,4)
                             KSth1<-round(test$KDcr5,4)
                             pvalue1<-test$px
                             rm(test)
                             } 
     }
################################
   if (estim.w==0 | nmc <= 0){ 
   KSemp2<-KSth2<-pvalue2<- "n.d." 
   errw1<-"p-value will not be calculated for female subjects" 
   cat("p-value will not be calculated for female subjects   \n")
   }else{
   try({
      test<-KS.rtpn.test(data=dwbm,est=estw,n1=nmc,alpha1=alpha1,sl=0.01,
      m1=101,nen=nen,epsilon=1E-4,I=100,mod=modw,com=com)
      }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
                             KSemp2<-KSth2<-pvalue2<- "n.d."          
                             errw1<-"error: p-value could not be calculated for female subjects."
                             cat("p-value could not be calculated for female subjects   \n")
                             }else{
                             KSemp2<-round(test$KolmEmp,4)
                             KSth2<-round(test$KDcr5,4)
                             pvalue2<-test$px
                             rm(test)
                             } 
      }
#######################
   if (estim.a==0 | nmc <= 0){ 
   KSemp3<-KSth3<-pvalue3<- "n.d."
   erra1<-"p-value will not be calculated for all subjects"  
   cat("p-value will not be calculated for alle subjects   \n")
   }else{
   try({
      test<-KS.rtpn.test(data=dbm,est=est,n1=nmc,alpha1=alpha1,sl=0.01,
      m1=101,nen=nen,epsilon=1E-4,I=100,mod=mod,com=com)
      }, silent = TRUE)  # end of try
      if (is.na(test$KDcr5)){
         KSemp3<-KSth3<-pvalue3<- "n.d."          
         erra1<-"error: p-value could not be calculated for all subjects."
         cat("p-value could not be calculated for all subjects   \n")
         }else{
         KSemp3<-round(test$KolmEmp,4)
         KSth3<-round(test$KDcr5,4)
         pvalue3<-test$px
         rm(test)
         } 
      }     
   } else {
   cat("without testing the null hypothesis (5.H.stat.)....\n")
   # n.d. (not done) instead of content
   KSemp1<-KSemp2<-KSemp3<-KSth1<-KSth2<-KSth3<-pvalue1<-pvalue2<-pvalue3<-"n.d."
   }
######################################################
##                                                  ##
##  5.B.CI   calculating 95% confidence intervals   ##
##           pathol==B                              ##
##                                                  ##
######################################################
#################################
  if (ci=="TRUE" & nrep > 0)
  {
    cat("calculating confidence intervals (5.H.CI.)....\n")
    mRLR<-mRLL<-wRLR<-wRLL<-RLR<-RLL<-c(rep(0,nrep)) 
    if (estim.a==1 & estim.w==1 & estim.m==1)
    {  # if estimations for male, female and all subjects were successfully.   
    try({
    j1<-1;
    while (j1<=nrep) 
         {
         datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
         if (model=="PN" | model=="G") {
            min1<-0
            } else {
            min1<-min(datasim11)
            }
         datasim1<-datasim11-min1
         TLmsam<-round(quantile(datasim1,q10m),com)
         TR2msam<-round(min(quantile(datasim1,Q2),max.TRm),com)
         bw1sam<-bw.nrd(datasim1)
         t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn0(d=datasim1,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            mRLR[j1]<-mRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1msam<-est1sam[4]
            estsam<-est.dtpn0(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1msam,TR2=TR1msam,nen=nen)
            lambda1sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            mRLL[j1]<-tmsam$RLL1+min1
            mRLR[j1]<-tmsam$RLR1+min1
            }         
         datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
         if (model=="PN" | model=="G") {
            min2<-0
            } else {
            min2<-min(datasim22)
            }
         datasim2<-datasim22-min2
         TLmsam<-round(quantile(datasim2,q10w),com)
         TR2msam<-round(min(quantile(datasim2,Q2),max.TRw),com)
         bw1sam<-bw.nrd(datasim2)
         t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn0(d=datasim2,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            wRLR[j1]<-wRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1wsam<-est1sam[4]
##############################################                           final estimation for female subjects (accuaracy of lambda: 0.01):
            estsam<-est.dtpn0(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1wsam,TR2=TR1wsam,nen=nen)
            lambda2sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            wRLL[j1]<-tmsam$RLL1+min2
            wRLR[j1]<-tmsam$RLR1+min2
###############################################
            }
         min0<-min(min1,min2)
         datasim<-c(datasim11,datasim22)
         datasim<-datasim-min0
         TLasam<-round(quantile(datasim,q10a),com)
         TR2asam<-round(min(quantile(datasim,Q2),max.TR),com)
         TR1msam1<-TR1msam+min1  # not transformed optimala truncation point for male
         TR1wsam1<-TR1wsam+min2  # not transformed optimala truncation point for female
         TR2asam1<-TR2asam+min0  # the first limit for trunction point for male+females
         Trr1sam1<-min(TR1msam1,TR1wsam1)
         Trr2sam1<-max(TR1msam1,TR1wsam1)
         tr1sam<-min(Trr1sam1,TR2asam1)-min0
         tr2sam<-min(Trr2sam1,TR2asam1)-min0
         bw1sam<-bw.nrd(datasim)
         t1sam<-density(x=datasim,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         Nmin<-minsize
         # Nmin =4000 for default
         # estimation of parameters for male and female groups, separately, limits the parameter estimation of
         # male+female, if the sample size in both groups are enough:
         if (min(n1,n2,n3) >=Nmin)  {
            lminsam<-min(lambda1sam,lambda2sam)
            lmaxsam<-max(lambda1sam,lambda2sam)
            nallsam<-(lmaxsam-lminsam)*100+1
            estsam<-est.dtpn0(d=datasim,l0=lminsam,sl=0.01,n=nallsam,TL=TLasam,mod=mod0sam,com=com,TR1=tr1sam,TR2=tr2sam,nen=nen)
            est1sam<-est$y0
################################
            if (est1sam[1,12]==1) {     # if no proper truncation points are found the program is stopped!!
               RLR[j1]<-RLL[j1]<-0
               } else {
               tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
               RLL[j1]<-tmsam$RLL1+min0
               RLR[j1]<-tmsam$RLR1+min0
               }
###############################################
            } else {
            estsam<-est.dtpn0(d=datasim,l0=l0,sl=0.1,n=n,TL=TLasam,mod=mod0sam,com=com,c2=dif1,TR2=TR2asam,nen=nen)
            est1sam<-estsam$y0
################################
            if (est1sam[1,12]==1) {    # if no proper truncation points are found the program is stopped!!
               RLR[j1]<-RLL[j1]<-0
               } else {
               lsam<-est1sam[8]
               TR1msam<-est1sam[4]
##############################################
               estsam<-est.dtpn0(d=datasim,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLasam,mod=mod0sam,com=com,TR1=TR1msam,TR2=TR1msam,nen=nen)
               tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
               RLL[j1]<-tmsam$RLL1+min0
               RLR[j1]<-tmsam$RLR1+min0
               }
            }
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
   RLL<-RLL[RLL=!0]
   RLR<-RLR[RLR=!0]
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
   ciDLL<-quantile(RLL,int)
   ciDLR<-quantile(RLR,int)
#######################
   LRL1<-ciDLL[1]
   LRL2<-ciDLL[2]
   URL1<-ciDLR[1]
   URL2<-ciDLR[2]
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
##############################   
   }, silent = TRUE)  # end of try
   if (length(mRLR) <= nrep/2)
   {   
   mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
    errm2<-"Confidence interval for male subjects has not been calculated"
   }   
   if (length(wRLR) <= nrep/2)
   {   
   wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
    errw2<-"Confidence interval for female subjects has not been calculated"
   }  
   if (length(RLR) <= nrep/2)
   {   
   LRL1<-LRL2<-URL1<-URL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
   }
   if(length(mRLR) <= nrep/2 & length(wRLR) <= nrep/2 & length(RLR) <= nrep/2)
   { 
   errmess<-"error: Confidence intervals could not be calculate. Set option confidence interval=FALSE"
   write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
   #quit(save = "no", status = 0, runLast = FALSE)
   } 
   }else if(estim.a == 0 &  estim.w==1 & estim.m==1)
   {
    LRL1<-LRL2<-URL1<-URL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    try({
    j1<-1;
    while (j1<=nrep) 
         {
         datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
         if (model=="PN" | model=="G") {
            min1<-0
            } else {
            min1<-min(datasim11)
            }
         datasim1<-datasim11-min1
         TLmsam<-round(quantile(datasim1,q10m),com)
         TR2msam<-round(min(quantile(datasim1,Q2),max.TRm),com)
         bw1sam<-bw.nrd(datasim1)
         t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn0(d=datasim1,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            mRLR[j1]<-mRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1msam<-est1sam[4]
            estsam<-est.dtpn0(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1msam,TR2=TR1msam,nen=nen)
            lambda1sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            mRLL[j1]<-tmsam$RLL1+min1
            mRLR[j1]<-tmsam$RLR1+min1
            }         
         datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
         if (model=="PN" | model=="G") {
            min2<-0
            } else {
            min2<-min(datasim22)
            }
         datasim2<-datasim22-min2
         TLmsam<-round(quantile(datasim2,q10w),com)
         TR2msam<-round(min(quantile(datasim2,Q2),max.TRw),com)
         bw1sam<-bw.nrd(datasim2)
         t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn0(d=datasim2,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            wRLR[j1]<-wRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1wsam<-est1sam[4]
##############################################                           final estimation for female subjects (accuaracy of lambda: 0.01):
            estsam<-est.dtpn0(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1wsam,TR2=TR1wsam,nen=nen)
            lambda2sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            wRLL[j1]<-tmsam$RLL1+min2
            wRLR[j1]<-tmsam$RLR1+min2
###############################################         
            }
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
##############################   
   }, silent = TRUE)  # end of try
   if (length(mRLR) <= nrep/2)  {   
      mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
      errm2<-"Confidence interval for male subjects has not been calculated"
      cat("Confidence interval for male subjects has not been calculated \n")
      }   
   if (length(wRLR) <= nrep/2)  {   
      wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
      errw2<-"Confidence interval for female subjects has not been calculated"
      cat("Confidence interval for female subjects has not been calculated \n")
      }  
   if (length(wRLR) <= nrep/2 & length(RLR) <= nrep/2)  {   
      errmess<-"error: Confidence intervals could not be calculated. Set option confidence interval=FALSE"
      cat("Confidence interals could not be calculated \n")
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
      #quit(save = "no", status = 0, runLast = FALSE)
      } 
   }else if (estim.w==0 & estim.m==1) {
    LRL1<-LRL2<-URL1<-URL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
        erra2<-"Confidence interval for all subjects has not been calculated"
        errw2<-"Confidence interval for female subjects has not been calculated"
        cat("Confidence interval for alle subjects has not been calculated \n")
        cat("Confidence interval for female subjects has not been calculated")
    try({
    j1<-1;
    while (j1<=nrep) {
         datasim11<-sample(x=dmbm1,size=n2,replace=TRUE)
         if (model=="PN" | model=="G") {
            min1<-0
            } else {
            min1<-min(datasim11)
            }
         datasim1<-datasim11-min1
         TLmsam<-round(quantile(datasim1,q10m),com)
         TR2msam<-round(min(quantile(datasim1,Q2),max.TRm),com)
         bw1sam<-bw.nrd(datasim1)
         t1sam<-density(x=datasim1,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn0(d=datasim1,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            mRLR[j1]<-mRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1msam<-est1sam[4]
            estsam<-est.dtpn0(d=datasim1,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1msam,TR2=TR1msam,nen=nen)
            lambda1sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            mRLL[j1]<-tmsam$RLL1+min1
            mRLR[j1]<-tmsam$RLR1+min1
            }         
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   mRLL<-mRLL[mRLL=!0]
   mRLR<-mRLR[mRLR=!0]
########################
##########################
   mciDLL<-quantile(mRLL,int)
   mciDLR<-quantile(mRLR,int)
#######################
   mLRL1<-mciDLL[1]
   mLRL2<-mciDLL[2]
   mURL1<-mciDLR[1]
   mURL2<-mciDLR[2]
###############################################
##############################   
   }, silent = TRUE)  # end of try
   if (length(mRLR) <= nrep/2) {   
      mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."   
      errmess<-"error: Confidence intervals could not be calculated. Set option confidence interval=FALSE"
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
      #quit(save = "no", status = 0, runLast = FALSE)
      } 
    }else if (estim.w==1 & estim.m==0) {
    LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-"n.d."
    erra2<-"Confidence interval for all subjects has not been calculated"
    errm2<-"Confidence interval for male subjects has not been calculated"
    cat("Confidence interval for all subjects has not been calculated  \n")
    cat("Confidence interval for male subjects has not been calculated  \n")
    try({
    j1<-1;
    while (j1<=nrep)  {
         datasim22<-sample(x=dwbm1,size=n3,replace=TRUE)
         if (model=="PN" | model=="G") {
            min2<-0
            } else {
            min2<-min(datasim22)
            }
         datasim2<-datasim22-min2
         TLmsam<-round(quantile(datasim2,q10w),com)
         TR2msam<-round(min(quantile(datasim2,Q2),max.TRw),com)
         bw1sam<-bw.nrd(datasim2)
         t1sam<-density(x=datasim2,bw=bw1sam,kernel="gaussian",from=0,na.rm=TRUE,cut=3,n=1000)
         k1sam<-t1sam$y
         u1sam<-t1sam$x
         a.maxsam<-which.max(k1sam)
         mod0sam<-u1sam[a.maxsam]
         estsam<-est.dtpn0(d=datasim2,l0=l0,sl=0.1,n=n,TL=TLmsam,mod=mod0sam,com=com,c2=dif1,TR2=TR2msam,nen=nen)
         est1sam<-estsam$y0
#########################
################################
         if (est1sam[1,12]==1) {  # if no proper truncation points are found the program is stopped!!
            wRLR[j1]<-wRLL[j1]<-0
            } else {
            lsam<-est1sam[8]
            TLmsam<-est1sam[3]
            TR1wsam<-est1sam[4]
##############################################                           final estimation for female subjects (accuaracy of lambda: 0.01):
            estsam<-est.dtpn0(d=datasim2,l0=max(0,lsam-lstep),sl=0.01,n=nstep,TL=TLmsam,mod=mod0sam,com=com,TR1=TR1wsam,TR2=TR1wsam,nen=nen)
            lambda2sam<-estsam$y0[8]
            tmsam<-RLs(est=estsam,com=com+2) # calculates RLs
            wRLL[j1]<-tmsam$RLL1+min2
            wRLR[j1]<-tmsam$RLR1+min2
###############################################         
            }    
###############################################
         j1<-j1+1
         }
##########################
###############################################
# As the program substitutes the estimations with zero for bad cases, we eliminate these values:
########################
# ci.. 90% CI of Percentiles
   beta<-0.10
   int<-c(beta/2,1-(beta)/2)
##########################
#########################
   wRLL<-wRLL[wRLL=!0]
   wRLR<-wRLR[wRLR=!0]
########################
   wciDLL<-quantile(wRLL,int)
   wciDLR<-quantile(wRLR,int)
#######################
   wLRL1<-wciDLL[1]
   wLRL2<-wciDLL[2]
   wURL1<-wciDLR[1]
   wURL2<-wciDLR[2]
###############################################
##############################   
   }, silent = TRUE)  # end of try
   if (length(wRLR) <= nrep/2) {   
      wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."   
      errmess<-"error: Confidence intervals could not be calculate. Set option confidence interval=FALSE"
      write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
      #quit(save = "no", status = 0, runLast = FALSE)
      }
   }else {      # if no estimation for male and female subjects are available
   cat("Confidence interval for all subjects has not been calculated \n")
   cat("Confidence interval for male subjects has not been calculated \n")
   cat("Confidence interval for female subjects has not been calculated \n")
   LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
   erra2<-"Confidence interval for all subjects has not been calculated"
   errm2<-"Confidence interval for male subjects has not been calculated"
   errw2<-"Confidence interval for female subjects has not been calculated"
   }
   } else {  # if CI = FALSE
   cat("no confidence intervals (5.H.CI) ....\n")
   # n.d. (not done) instead of content
   LRL1<-LRL2<-URL1<-URL2<-mLRL1<-mLRL2<-mURL1<-mURL2<-wLRL1<-wLRL2<-wURL1<-wURL2<-"n.d."
   }
######################################################################
}                        # end of calculation
######################################################################
######################################################################
###                                                                ###
### write results in data frame and csv for all calculations       ###
###                                                                ###
######################################################################
######################################################################
try({
h0<-c("male","female","all")
h0.age<-rep(paste(a1,"-",a2),3)
h1<-c(n2,n3,n1)
h2<-c(modm1,modw1,mod1)
h3<-c(p1,p2,p3)
h4<-c(mu1,mu2,mu3)
h5<-c(sig1,sig2,sig3)
h6<-c(lam1,lam2,lam3)
h7<-c(LR1,LR2,LR3)
h8<-c(UR1,UR2,UR3)
h10<-c(KSemp1,KSemp2,KSemp3)
h11<-c(KSth1,KSth2,KSth3)
h12<-c(pvalue1,pvalue2,pvalue3)
h13<-c(mLRL1,wLRL1,LRL1)
h14<-c(mLRL2,wLRL2,LRL2)
h15<-c(mURL1,wURL1,URL1)
h16<-c(mURL2,wURL2,URL2)
h17<-c(mpU.LRL1,wpU.LRL1,pU.LRL1)
h18<-c(mpU.LRL2,wpU.LRL2,pU.LRL2)
h19<-c(mpU.URL1,wpU.URL1,pU.URL1)
h20<-c(mpU.URL2,wpU.URL2,pU.URL2)
d<-data.frame(h0,h0.age,h1,h7,h8,h17,h18,h19,h20,h13,h14,h15,h16,h10,h11,h12,h2,h3,h4,h5,h6)
colnames(d)<-c("Pop.","Age","N","lower RL","upper RL","L-pU-LRL","U-pU-LRL","L-pU-URL","U-pU-URL","L-CI-LRL","U-CI-LRL","L-CI-URL","U-CI-URL","Test value","Critical value","P value","Mode","P","mu","Sigma","lambda")
}, silent = TRUE)
### copy in flag file and subfolder:
try({
   write.table(d, file = flag_file,quote=FALSE,sep=";",col.names=TRUE)
   write.csv(d, file = savename2,quote=FALSE)
   Result2<-paste(result_file1,"/","result2.csv",sep="")
   write.csv(d, file = Result2,quote=FALSE)
   })
errmess<-geterrmessage() 
if (errmess!="" &(estim.a==0 & estim.w==0 & estim.m==0)){            
   errmess<-"error: either distribution of non-path. values could not be separated from the whole data or p-value or confidence interval could not be calculated. Try again but  
                    without estimation of confidence interval and statistical test, or use another option for pathological values."
   }else{
   errmess<-"no error"
   }
write.csv(errmess, file=error_file,quote=FALSE, row.names = FALSE, eol = "\n")
write.table(errmess, file=flag_file,quote=FALSE, row.names = FALSE, append=TRUE, eol = "\n")
##############################################################
sink(file=logdat,append=TRUE, split=TRUE,type = c("output","message"))
end.time <- date()
cat("Program start:", start.time,"\n")
cat("program end:  ", end.time,"\n")
cat("================================================================\n\n")
cat("estimation of RLs:","\n")
cat("male subjects:", errm , "\n")
cat("female subjects:", errw , "\n")
cat("all subjects:", erra , "\n\n")
cat("================================================================\n\n")
cat("estimation of P-Values for statistical test:","\n")
if(stat_test==FALSE) {cat("not done","\n")}else{
cat("number of MC-Simulations:", nmc, "\n")
cat("male subjects:", errm1, "\n")
cat("female subjects:", errw1, "\n")
cat("all subjects:", erra1 , "\n\n")
}
cat("================================================================\n\n")
cat("estimation of confidence interval:","\n")
if(ci==FALSE) {cat("not done","\n")}else{
cat("number of Bootstraps:", nrep, "\n")
cat("male subjects:", errm2 , "\n")
cat("female subjects:", errw2 , "\n")
cat("all subjects:", erra2 , "\n")
}
cat("R_program2 finished\n")
sink()
##################################
quit(save = "no", status = 0, runLast = FALSE)